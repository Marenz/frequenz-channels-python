{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Frequenz channels \u00a4 This repository contains channel implementations for python. Contributing \u00a4 If you want to know how to build this project and contribute to it, please check out the Contributing Guide .","title":"Home"},{"location":"#frequenz-channels","text":"This repository contains channel implementations for python.","title":"Frequenz channels"},{"location":"#contributing","text":"If you want to know how to build this project and contribute to it, please check out the Contributing Guide .","title":"Contributing"},{"location":"CONTRIBUTING/","text":"Contributing to frequenz-channels \u00a4 Build \u00a4 You can use build to simply build the source and binary distribution: python -m pip install build python -m build Local development \u00a4 You can use editable installs to develop the project locally (it will install all the dependencies too): python -m pip install -e . You can also use nox to run the tests and other checks: python -m pip install nox nox To build the documentation, first install the dependencies: python -m pip install -e . [ docs ] Then you can build the documentation (it will be written in the site/ directory): mkdocs build Or you can just serve the documentation without building it using: mkdocs serve Your site will be updated live when you change your files (provided that you used pip install -e . , beware of a common pitfall of using pip install without -e , in that case the API reference won't change unless you do a new pip install ). To build multi-version documentation, we use mike . If you want to see how the multi-version sites looks like locally, you can use: mike deploy my-version mike set-default my-version mike serve mike works in mysterious ways. Some basic information: mike deploy will do a mike build and write the results to your local gh-pages branch. my-version is an arbitrary name for the local version you want to preview. mike set-default is needed so when you serve the documentation, it goes to your newly produced documentation by default. mike serve will serve the contents of your local gh-pages branch. Be aware that, unlike mkdocs serve , changes to the sources won't be shown live, as the mike deploy step is needed to refresh them. Be careful not to use --push with mike deploy , otherwise it will push your local gh-pages branch to the origin remote. That said, if you want to test the actual website in your fork , you can always use mike deploy --push --remote your-fork-remote , and then access the GitHub pages produced for your fork. Releasing \u00a4 These are the steps to create a new release: Get the latest head you want to create a release from. Update the RELEASE_NOTES.md file if it is not complete, up to date, and clean from template comments ( <!-- ... -> ) and empty sections. Submit a pull request if an update is needed, wait until it is merged, and update the latest head you want to create a release from to get the new merged pull request. Create a new signed tag using the release notes and a semver compatible version number with a v prefix, for example: git tag -s -F RELEASE_NOTES.md v0.0.1 Push the new tag. A GitHub action will test the tag and if all goes well it will create a GitHub Release , create a new announcement about the release, and upload a new package to PyPI automatically. Once this is done, reset the RELEASE_NOTES.md with the template: cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md Commit the new release notes and create a PR (this step should be automated eventually too). Celebrate!","title":"Development"},{"location":"CONTRIBUTING/#contributing-to-frequenz-channels","text":"","title":"Contributing to frequenz-channels"},{"location":"CONTRIBUTING/#build","text":"You can use build to simply build the source and binary distribution: python -m pip install build python -m build","title":"Build"},{"location":"CONTRIBUTING/#local-development","text":"You can use editable installs to develop the project locally (it will install all the dependencies too): python -m pip install -e . You can also use nox to run the tests and other checks: python -m pip install nox nox To build the documentation, first install the dependencies: python -m pip install -e . [ docs ] Then you can build the documentation (it will be written in the site/ directory): mkdocs build Or you can just serve the documentation without building it using: mkdocs serve Your site will be updated live when you change your files (provided that you used pip install -e . , beware of a common pitfall of using pip install without -e , in that case the API reference won't change unless you do a new pip install ). To build multi-version documentation, we use mike . If you want to see how the multi-version sites looks like locally, you can use: mike deploy my-version mike set-default my-version mike serve mike works in mysterious ways. Some basic information: mike deploy will do a mike build and write the results to your local gh-pages branch. my-version is an arbitrary name for the local version you want to preview. mike set-default is needed so when you serve the documentation, it goes to your newly produced documentation by default. mike serve will serve the contents of your local gh-pages branch. Be aware that, unlike mkdocs serve , changes to the sources won't be shown live, as the mike deploy step is needed to refresh them. Be careful not to use --push with mike deploy , otherwise it will push your local gh-pages branch to the origin remote. That said, if you want to test the actual website in your fork , you can always use mike deploy --push --remote your-fork-remote , and then access the GitHub pages produced for your fork.","title":"Local development"},{"location":"CONTRIBUTING/#releasing","text":"These are the steps to create a new release: Get the latest head you want to create a release from. Update the RELEASE_NOTES.md file if it is not complete, up to date, and clean from template comments ( <!-- ... -> ) and empty sections. Submit a pull request if an update is needed, wait until it is merged, and update the latest head you want to create a release from to get the new merged pull request. Create a new signed tag using the release notes and a semver compatible version number with a v prefix, for example: git tag -s -F RELEASE_NOTES.md v0.0.1 Push the new tag. A GitHub action will test the tag and if all goes well it will create a GitHub Release , create a new announcement about the release, and upload a new package to PyPI automatically. Once this is done, reset the RELEASE_NOTES.md with the template: cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md Commit the new release notes and create a PR (this step should be automated eventually too). Celebrate!","title":"Releasing"},{"location":"SUMMARY/","text":"Home API Reference Development","title":"SUMMARY"},{"location":"reference/SUMMARY/","text":"frequenz channels anycast base_classes bidirectional broadcast merge merge_named select utils file_watcher timer","title":"SUMMARY"},{"location":"reference/frequenz/channels/","text":"frequenz.channels \u00a4 Channel implementations. Classes \u00a4 frequenz.channels.Anycast \u00a4 Bases: Generic [ T ] A channel for sending data across async tasks. Anycast channels support multiple senders and multiple receivers. A message sent through a sender will be received by exactly one receiver. In cases where each message need to be received by every receiver, a Broadcast channel may be used. Uses an deque internally, so Anycast channels are not thread-safe. When there are multiple channel receivers, they can be awaited simultaneously using Select , Merge or MergeNamed . Example async def send ( sender : channel . Sender ) -> None : while True : next = random . randint ( 3 , 17 ) print ( f \"sending: { next } \" ) await sender . send ( next ) async def recv ( id : int , receiver : channel . Receiver ) -> None : while True : next = await receiver . receive () print ( f \"receiver_ { id } received { next } \" ) await asyncio . sleep ( 0.1 ) # sleep (or work) with the data acast = channel . Anycast () sender = acast . get_sender () receiver_1 = acast . get_receiver () asyncio . create_task ( send ( sender )) await recv ( 1 , receiver_1 ) Check the tests and benchmarks directories for more examples. Source code in frequenz/channels/anycast.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 class Anycast ( Generic [ T ]): \"\"\"A channel for sending data across async tasks. Anycast channels support multiple senders and multiple receivers. A message sent through a sender will be received by exactly one receiver. In cases where each message need to be received by every receiver, a [Broadcast][frequenz.channels.Broadcast] channel may be used. Uses an [deque][collections.deque] internally, so Anycast channels are not thread-safe. When there are multiple channel receivers, they can be awaited simultaneously using [Select][frequenz.channels.Select], [Merge][frequenz.channels.Merge] or [MergeNamed][frequenz.channels.MergeNamed]. Example: ``` python async def send(sender: channel.Sender) -> None: while True: next = random.randint(3, 17) print(f\"sending: {next}\") await sender.send(next) async def recv(id: int, receiver: channel.Receiver) -> None: while True: next = await receiver.receive() print(f\"receiver_{id} received {next}\") await asyncio.sleep(0.1) # sleep (or work) with the data acast = channel.Anycast() sender = acast.get_sender() receiver_1 = acast.get_receiver() asyncio.create_task(send(sender)) await recv(1, receiver_1) ``` Check the `tests` and `benchmarks` directories for more examples. \"\"\" def __init__ ( self , maxsize : int = 10 ) -> None : \"\"\"Create an Anycast channel. Args: maxsize: Size of the channel's buffer. \"\"\" self . limit : int = maxsize self . deque : Deque [ T ] = deque ( maxlen = maxsize ) self . send_cv : Condition = Condition () self . recv_cv : Condition = Condition () self . closed : bool = False async def close ( self ) -> None : \"\"\"Close the channel. Any further attempts to [send()][frequenz.channels.Sender.send] data will return `False`. Receivers will still be able to drain the pending items on the channel, but after that, subsequent [receive()][frequenz.channels.Receiver.receive] calls will return `None` immediately. \"\"\" self . closed = True async with self . send_cv : self . send_cv . notify_all () async with self . recv_cv : self . recv_cv . notify_all () def get_sender ( self ) -> Sender [ T ]: \"\"\"Create a new sender. Returns: A Sender instance attached to the Anycast channel. \"\"\" return Sender ( self ) def get_receiver ( self ) -> Receiver [ T ]: \"\"\"Create a new receiver. Returns: A Receiver instance attached to the Anycast channel. \"\"\" return Receiver ( self ) Functions \u00a4 __init__ ( maxsize = 10 ) \u00a4 Create an Anycast channel. PARAMETER DESCRIPTION maxsize Size of the channel's buffer. TYPE: int DEFAULT: 10 Source code in frequenz/channels/anycast.py 63 64 65 66 67 68 69 70 71 72 73 def __init__ ( self , maxsize : int = 10 ) -> None : \"\"\"Create an Anycast channel. Args: maxsize: Size of the channel's buffer. \"\"\" self . limit : int = maxsize self . deque : Deque [ T ] = deque ( maxlen = maxsize ) self . send_cv : Condition = Condition () self . recv_cv : Condition = Condition () self . closed : bool = False close () async \u00a4 Close the channel. Any further attempts to send() data will return False . Receivers will still be able to drain the pending items on the channel, but after that, subsequent receive() calls will return None immediately. Source code in frequenz/channels/anycast.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 async def close ( self ) -> None : \"\"\"Close the channel. Any further attempts to [send()][frequenz.channels.Sender.send] data will return `False`. Receivers will still be able to drain the pending items on the channel, but after that, subsequent [receive()][frequenz.channels.Receiver.receive] calls will return `None` immediately. \"\"\" self . closed = True async with self . send_cv : self . send_cv . notify_all () async with self . recv_cv : self . recv_cv . notify_all () get_receiver () \u00a4 Create a new receiver. RETURNS DESCRIPTION Receiver [ T ] A Receiver instance attached to the Anycast channel. Source code in frequenz/channels/anycast.py 101 102 103 104 105 106 107 def get_receiver ( self ) -> Receiver [ T ]: \"\"\"Create a new receiver. Returns: A Receiver instance attached to the Anycast channel. \"\"\" return Receiver ( self ) get_sender () \u00a4 Create a new sender. RETURNS DESCRIPTION Sender [ T ] A Sender instance attached to the Anycast channel. Source code in frequenz/channels/anycast.py 93 94 95 96 97 98 99 def get_sender ( self ) -> Sender [ T ]: \"\"\"Create a new sender. Returns: A Sender instance attached to the Anycast channel. \"\"\" return Sender ( self ) frequenz.channels.Bidirectional \u00a4 Bases: Generic [ T , U ] A wrapper class for simulating bidirectional channels. Source code in frequenz/channels/bidirectional.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Bidirectional ( Generic [ T , U ]): \"\"\"A wrapper class for simulating bidirectional channels.\"\"\" def __init__ ( self , client_id : str , service_id : str ) -> None : \"\"\"Create a `Bidirectional` instance. Args: client_id: A name for the client, used to name the channels. service_id: A name for the service end of the channels. \"\"\" self . _client_id = client_id self . _request_channel : Broadcast [ T ] = Broadcast ( f \"req_ { service_id } _ { client_id } \" ) self . _response_channel : Broadcast [ U ] = Broadcast ( f \"resp_ { service_id } _ { client_id } \" ) self . _client_handle = BidirectionalHandle ( self . _request_channel . get_sender (), self . _response_channel . get_receiver (), ) self . _service_handle = BidirectionalHandle ( self . _response_channel . get_sender (), self . _request_channel . get_receiver (), ) @property def client_handle ( self ) -> BidirectionalHandle [ T , U ]: \"\"\"Get a BidirectionalHandle for the client to use. Returns: Object to send/receive messages with. \"\"\" return self . _client_handle @property def service_handle ( self ) -> BidirectionalHandle [ U , T ]: \"\"\"Get a `BidirectionalHandle` for the service to use. Returns: Object to send/receive messages with. \"\"\" return self . _service_handle Functions \u00a4 __init__ ( client_id , service_id ) \u00a4 Create a Bidirectional instance. PARAMETER DESCRIPTION client_id A name for the client, used to name the channels. TYPE: str service_id A name for the service end of the channels. TYPE: str Source code in frequenz/channels/bidirectional.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , client_id : str , service_id : str ) -> None : \"\"\"Create a `Bidirectional` instance. Args: client_id: A name for the client, used to name the channels. service_id: A name for the service end of the channels. \"\"\" self . _client_id = client_id self . _request_channel : Broadcast [ T ] = Broadcast ( f \"req_ { service_id } _ { client_id } \" ) self . _response_channel : Broadcast [ U ] = Broadcast ( f \"resp_ { service_id } _ { client_id } \" ) self . _client_handle = BidirectionalHandle ( self . _request_channel . get_sender (), self . _response_channel . get_receiver (), ) self . _service_handle = BidirectionalHandle ( self . _response_channel . get_sender (), self . _request_channel . get_receiver (), ) client_handle () property \u00a4 Get a BidirectionalHandle for the client to use. RETURNS DESCRIPTION BidirectionalHandle [ T , U ] Object to send/receive messages with. Source code in frequenz/channels/bidirectional.py 39 40 41 42 43 44 45 46 @property def client_handle ( self ) -> BidirectionalHandle [ T , U ]: \"\"\"Get a BidirectionalHandle for the client to use. Returns: Object to send/receive messages with. \"\"\" return self . _client_handle service_handle () property \u00a4 Get a BidirectionalHandle for the service to use. RETURNS DESCRIPTION BidirectionalHandle [ U , T ] Object to send/receive messages with. Source code in frequenz/channels/bidirectional.py 48 49 50 51 52 53 54 55 @property def service_handle ( self ) -> BidirectionalHandle [ U , T ]: \"\"\"Get a `BidirectionalHandle` for the service to use. Returns: Object to send/receive messages with. \"\"\" return self . _service_handle frequenz.channels.BidirectionalHandle \u00a4 Bases: Sender [ T ] , Receiver [ U ] A handle to a Bidirectional instance. It can be used to send/receive values between the client and service. Source code in frequenz/channels/bidirectional.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class BidirectionalHandle ( Sender [ T ], Receiver [ U ]): \"\"\"A handle to a [Bidirectional][frequenz.channels.Bidirectional] instance. It can be used to send/receive values between the client and service. \"\"\" def __init__ ( self , sender : Sender [ T ], receiver : Receiver [ U ]) -> None : \"\"\"Create a `BidirectionalHandle` instance. Args: sender: A sender to send values with. receiver: A receiver to receive values from. \"\"\" self . _sender = sender self . _receiver = receiver async def send ( self , msg : T ) -> bool : \"\"\"Send a value to the other side. Args: msg: The value to send. Returns: Whether the send was successful or not. \"\"\" return await self . _sender . send ( msg ) async def receive ( self ) -> Optional [ U ]: \"\"\"Receive a value from the other side. Returns: Received value, or `None` if the channels are closed. \"\"\" return await self . _receiver . receive () Functions \u00a4 __init__ ( sender , receiver ) \u00a4 Create a BidirectionalHandle instance. PARAMETER DESCRIPTION sender A sender to send values with. TYPE: Sender [ T ] receiver A receiver to receive values from. TYPE: Receiver [ U ] Source code in frequenz/channels/bidirectional.py 64 65 66 67 68 69 70 71 72 def __init__ ( self , sender : Sender [ T ], receiver : Receiver [ U ]) -> None : \"\"\"Create a `BidirectionalHandle` instance. Args: sender: A sender to send values with. receiver: A receiver to receive values from. \"\"\" self . _sender = sender self . _receiver = receiver receive () async \u00a4 Receive a value from the other side. RETURNS DESCRIPTION Optional [ U ] Received value, or None if the channels are closed. Source code in frequenz/channels/bidirectional.py 85 86 87 88 89 90 91 async def receive ( self ) -> Optional [ U ]: \"\"\"Receive a value from the other side. Returns: Received value, or `None` if the channels are closed. \"\"\" return await self . _receiver . receive () send ( msg ) async \u00a4 Send a value to the other side. PARAMETER DESCRIPTION msg The value to send. TYPE: T RETURNS DESCRIPTION bool Whether the send was successful or not. Source code in frequenz/channels/bidirectional.py 74 75 76 77 78 79 80 81 82 83 async def send ( self , msg : T ) -> bool : \"\"\"Send a value to the other side. Args: msg: The value to send. Returns: Whether the send was successful or not. \"\"\" return await self . _sender . send ( msg ) frequenz.channels.Broadcast \u00a4 Bases: Generic [ T ] A channel to broadcast messages to multiple receivers. Broadcast channels can have multiple senders and multiple receivers. Each message sent through any of the senders is received by all of the receivers. Internally, a broadcast receiver's buffer is implemented with just append/pop operations on either side of a deque , which are thread-safe. Because of this, Broadcast channels are thread-safe. When there are multiple channel receivers, they can be awaited simultaneously using Select , Merge or MergeNamed . Example async def send ( sender : channel . Sender ) -> None : while True : next = random . randint ( 3 , 17 ) print ( f \"sending: { next } \" ) await sender . send ( next ) async def recv ( id : int , receiver : channel . Receiver ) -> None : while True : next = await receiver . receive () print ( f \"receiver_ { id } received { next } \" ) await asyncio . sleep ( 0.1 ) # sleep (or work) with the data bcast = channel . Broadcast () sender = bcast . get_sender () receiver_1 = bcast . get_receiver () asyncio . create_task ( send ( sender )) await recv ( 1 , receiver_1 ) Check the tests and benchmarks directories for more examples. Source code in frequenz/channels/broadcast.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class Broadcast ( Generic [ T ]): \"\"\"A channel to broadcast messages to multiple receivers. `Broadcast` channels can have multiple senders and multiple receivers. Each message sent through any of the senders is received by all of the receivers. Internally, a broadcast receiver's buffer is implemented with just append/pop operations on either side of a [deque][collections.deque], which are thread-safe. Because of this, `Broadcast` channels are thread-safe. When there are multiple channel receivers, they can be awaited simultaneously using [Select][frequenz.channels.Select], [Merge][frequenz.channels.Merge] or [MergeNamed][frequenz.channels.MergeNamed]. Example: ``` python async def send(sender: channel.Sender) -> None: while True: next = random.randint(3, 17) print(f\"sending: {next}\") await sender.send(next) async def recv(id: int, receiver: channel.Receiver) -> None: while True: next = await receiver.receive() print(f\"receiver_{id} received {next}\") await asyncio.sleep(0.1) # sleep (or work) with the data bcast = channel.Broadcast() sender = bcast.get_sender() receiver_1 = bcast.get_receiver() asyncio.create_task(send(sender)) await recv(1, receiver_1) ``` Check the `tests` and `benchmarks` directories for more examples. \"\"\" def __init__ ( self , name : str , resend_latest : bool = False ) -> None : \"\"\"Create a Broadcast channel. Args: name: A name for the broadcast channel, typically based on the type of data sent through it. Used to identify the channel in the logs. resend_latest: When True, every time a new receiver is created with `get_receiver`, it will automatically get sent the latest value on the channel. This allows new receivers on slow streams to get the latest value as soon as they are created, without having to wait for the next message on the channel to arrive. \"\"\" self . name : str = name self . _resend_latest = resend_latest self . recv_cv : Condition = Condition () self . receivers : Dict [ UUID , Receiver [ T ]] = {} self . closed : bool = False self . _latest : Optional [ T ] = None async def close ( self ) -> None : \"\"\"Close the Broadcast channel. Any further attempts to [send()][frequenz.channels.Sender.send] data will return `False`. Receivers will still be able to drain the pending items on their queues, but after that, subsequent [receive()][frequenz.channels.Receiver.receive] calls will return `None` immediately. \"\"\" self . _latest = None self . closed = True async with self . recv_cv : self . recv_cv . notify_all () def _drop_receiver ( self , uuid : UUID ) -> None : \"\"\"Drop a specific receiver from the list of broadcast receivers. Called from the destructors of receivers. Args: uuid: a uuid identifying the receiver to be dropped. \"\"\" if uuid in self . receivers : del self . receivers [ uuid ] def get_sender ( self ) -> Sender [ T ]: \"\"\"Create a new broadcast sender. Returns: A Sender instance attached to the broadcast channel. \"\"\" return Sender ( self ) def get_receiver ( self , name : Optional [ str ] = None , maxsize : int = 50 ) -> Receiver [ T ]: \"\"\"Create a new broadcast receiver. Broadcast receivers have their own buffer, and when messages are not being consumed fast enough and the buffer fills up, old messages will get dropped just in this receiver. Args: name: A name to identify the receiver in the logs. maxsize: Size of the receiver's buffer. Returns: A Receiver instance attached to the broadcast channel. \"\"\" uuid = uuid4 () if name is None : name = str ( uuid ) recv : Receiver [ T ] = Receiver ( uuid , name , maxsize , self ) self . receivers [ uuid ] = recv if self . _resend_latest and self . _latest is not None : recv . enqueue ( self . _latest ) return recv def get_peekable ( self ) -> Peekable [ T ]: \"\"\"Create a new Peekable for the broadcast channel. A Peekable provides a [peek()][frequenz.channels.Peekable.peek] method that allows the user to get a peek at the latest value in the channel, without consuming anything. Returns: A Peekable to peek into the broadcast channel with. \"\"\" return Peekable ( self ) Functions \u00a4 __init__ ( name , resend_latest = False ) \u00a4 Create a Broadcast channel. PARAMETER DESCRIPTION name A name for the broadcast channel, typically based on the type of data sent through it. Used to identify the channel in the logs. TYPE: str resend_latest When True, every time a new receiver is created with get_receiver , it will automatically get sent the latest value on the channel. This allows new receivers on slow streams to get the latest value as soon as they are created, without having to wait for the next message on the channel to arrive. TYPE: bool DEFAULT: False Source code in frequenz/channels/broadcast.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def __init__ ( self , name : str , resend_latest : bool = False ) -> None : \"\"\"Create a Broadcast channel. Args: name: A name for the broadcast channel, typically based on the type of data sent through it. Used to identify the channel in the logs. resend_latest: When True, every time a new receiver is created with `get_receiver`, it will automatically get sent the latest value on the channel. This allows new receivers on slow streams to get the latest value as soon as they are created, without having to wait for the next message on the channel to arrive. \"\"\" self . name : str = name self . _resend_latest = resend_latest self . recv_cv : Condition = Condition () self . receivers : Dict [ UUID , Receiver [ T ]] = {} self . closed : bool = False self . _latest : Optional [ T ] = None close () async \u00a4 Close the Broadcast channel. Any further attempts to send() data will return False . Receivers will still be able to drain the pending items on their queues, but after that, subsequent receive() calls will return None immediately. Source code in frequenz/channels/broadcast.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 async def close ( self ) -> None : \"\"\"Close the Broadcast channel. Any further attempts to [send()][frequenz.channels.Sender.send] data will return `False`. Receivers will still be able to drain the pending items on their queues, but after that, subsequent [receive()][frequenz.channels.Receiver.receive] calls will return `None` immediately. \"\"\" self . _latest = None self . closed = True async with self . recv_cv : self . recv_cv . notify_all () get_peekable () \u00a4 Create a new Peekable for the broadcast channel. A Peekable provides a peek() method that allows the user to get a peek at the latest value in the channel, without consuming anything. RETURNS DESCRIPTION Peekable [ T ] A Peekable to peek into the broadcast channel with. Source code in frequenz/channels/broadcast.py 148 149 150 151 152 153 154 155 156 157 158 def get_peekable ( self ) -> Peekable [ T ]: \"\"\"Create a new Peekable for the broadcast channel. A Peekable provides a [peek()][frequenz.channels.Peekable.peek] method that allows the user to get a peek at the latest value in the channel, without consuming anything. Returns: A Peekable to peek into the broadcast channel with. \"\"\" return Peekable ( self ) get_receiver ( name = None , maxsize = 50 ) \u00a4 Create a new broadcast receiver. Broadcast receivers have their own buffer, and when messages are not being consumed fast enough and the buffer fills up, old messages will get dropped just in this receiver. PARAMETER DESCRIPTION name A name to identify the receiver in the logs. TYPE: Optional [ str ] DEFAULT: None maxsize Size of the receiver's buffer. TYPE: int DEFAULT: 50 RETURNS DESCRIPTION Receiver [ T ] A Receiver instance attached to the broadcast channel. Source code in frequenz/channels/broadcast.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def get_receiver ( self , name : Optional [ str ] = None , maxsize : int = 50 ) -> Receiver [ T ]: \"\"\"Create a new broadcast receiver. Broadcast receivers have their own buffer, and when messages are not being consumed fast enough and the buffer fills up, old messages will get dropped just in this receiver. Args: name: A name to identify the receiver in the logs. maxsize: Size of the receiver's buffer. Returns: A Receiver instance attached to the broadcast channel. \"\"\" uuid = uuid4 () if name is None : name = str ( uuid ) recv : Receiver [ T ] = Receiver ( uuid , name , maxsize , self ) self . receivers [ uuid ] = recv if self . _resend_latest and self . _latest is not None : recv . enqueue ( self . _latest ) return recv get_sender () \u00a4 Create a new broadcast sender. RETURNS DESCRIPTION Sender [ T ] A Sender instance attached to the broadcast channel. Source code in frequenz/channels/broadcast.py 115 116 117 118 119 120 121 def get_sender ( self ) -> Sender [ T ]: \"\"\"Create a new broadcast sender. Returns: A Sender instance attached to the broadcast channel. \"\"\" return Sender ( self ) frequenz.channels.BufferedReceiver \u00a4 Bases: Receiver [ T ] A channel receiver with a buffer. Source code in frequenz/channels/base_classes.py 107 108 109 110 111 112 113 114 115 116 class BufferedReceiver ( Receiver [ T ]): \"\"\"A channel receiver with a buffer.\"\"\" @abstractmethod def enqueue ( self , msg : T ) -> None : \"\"\"Put a message into this buffered receiver's queue. Args: msg: The message to be added to the queue. \"\"\" Functions \u00a4 enqueue ( msg ) abstractmethod \u00a4 Put a message into this buffered receiver's queue. PARAMETER DESCRIPTION msg The message to be added to the queue. TYPE: T Source code in frequenz/channels/base_classes.py 110 111 112 113 114 115 116 @abstractmethod def enqueue ( self , msg : T ) -> None : \"\"\"Put a message into this buffered receiver's queue. Args: msg: The message to be added to the queue. \"\"\" frequenz.channels.FileWatcher \u00a4 Bases: Receiver [ pathlib . Path ] A channel receiver that watches for file events. Source code in frequenz/channels/utils/file_watcher.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class FileWatcher ( Receiver [ pathlib . Path ]): \"\"\"A channel receiver that watches for file events.\"\"\" def __init__ ( self , paths : List [ Union [ pathlib . Path , str ]], event_types : Optional [ Set [ EventType ]] = None , ) -> None : \"\"\"Create a `FileWatcher` instance. Args: paths: Paths to watch for changes. event_types: Types of events to watch for or `None` to watch for all event types. \"\"\" if event_types is None : event_types = { EventType . CREATE , EventType . MODIFY , EventType . DELETE } self . event_types = event_types self . _stop_event = asyncio . Event () self . _paths = [ path if isinstance ( path , pathlib . Path ) else pathlib . Path ( path ) for path in paths ] self . _awatch = awatch ( * self . _paths , stop_event = self . _stop_event , watch_filter = lambda change , path_str : ( change in [ event_type . value for event_type in event_types ] # type: ignore and pathlib . Path ( path_str ) . is_file () ), ) def __del__ ( self ) -> None : \"\"\"Cleanup registered watches. `awatch` passes the `stop_event` to a separate task/thread. This way `awatch` getting destroyed properly. The background task will continue until the signal is received. \"\"\" self . _stop_event . set () async def receive ( self ) -> Optional [ pathlib . Path ]: \"\"\"Wait for the next file event and return its path. Returns: Path of next file. \"\"\" while True : changes = await self . _awatch . __anext__ () for change in changes : # Tuple of (Change, path) returned by watchfiles if change is None or len ( change ) != 2 : return None _ , path_str = change path = pathlib . Path ( path_str ) return path Functions \u00a4 __del__ () \u00a4 Cleanup registered watches. awatch passes the stop_event to a separate task/thread. This way awatch getting destroyed properly. The background task will continue until the signal is received. Source code in frequenz/channels/utils/file_watcher.py 56 57 58 59 60 61 62 63 def __del__ ( self ) -> None : \"\"\"Cleanup registered watches. `awatch` passes the `stop_event` to a separate task/thread. This way `awatch` getting destroyed properly. The background task will continue until the signal is received. \"\"\" self . _stop_event . set () __init__ ( paths , event_types = None ) \u00a4 Create a FileWatcher instance. PARAMETER DESCRIPTION paths Paths to watch for changes. TYPE: List [ Union [ pathlib . Path , str ]] event_types Types of events to watch for or None to watch for all event types. TYPE: Optional [ Set [ EventType ]] DEFAULT: None Source code in frequenz/channels/utils/file_watcher.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def __init__ ( self , paths : List [ Union [ pathlib . Path , str ]], event_types : Optional [ Set [ EventType ]] = None , ) -> None : \"\"\"Create a `FileWatcher` instance. Args: paths: Paths to watch for changes. event_types: Types of events to watch for or `None` to watch for all event types. \"\"\" if event_types is None : event_types = { EventType . CREATE , EventType . MODIFY , EventType . DELETE } self . event_types = event_types self . _stop_event = asyncio . Event () self . _paths = [ path if isinstance ( path , pathlib . Path ) else pathlib . Path ( path ) for path in paths ] self . _awatch = awatch ( * self . _paths , stop_event = self . _stop_event , watch_filter = lambda change , path_str : ( change in [ event_type . value for event_type in event_types ] # type: ignore and pathlib . Path ( path_str ) . is_file () ), ) receive () async \u00a4 Wait for the next file event and return its path. RETURNS DESCRIPTION Optional [ pathlib . Path ] Path of next file. Source code in frequenz/channels/utils/file_watcher.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 async def receive ( self ) -> Optional [ pathlib . Path ]: \"\"\"Wait for the next file event and return its path. Returns: Path of next file. \"\"\" while True : changes = await self . _awatch . __anext__ () for change in changes : # Tuple of (Change, path) returned by watchfiles if change is None or len ( change ) != 2 : return None _ , path_str = change path = pathlib . Path ( path_str ) return path frequenz.channels.Merge \u00a4 Bases: Receiver [ T ] Merge messages coming from multiple channels into a single stream. Example For example, if there are two channel receivers with the same type, they can be awaited together, and their results merged into a single stream, by using Merge like this: merge = Merge ( receiver1 , receiver2 ) while msg := await merge . receive (): # do something with msg pass Source code in frequenz/channels/merge.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class Merge ( Receiver [ T ]): \"\"\"Merge messages coming from multiple channels into a single stream. Example: For example, if there are two channel receivers with the same type, they can be awaited together, and their results merged into a single stream, by using `Merge` like this: ```python merge = Merge(receiver1, receiver2) while msg := await merge.receive(): # do something with msg pass ``` \"\"\" def __init__ ( self , * args : Receiver [ T ]) -> None : \"\"\"Create a `Merge` instance. Args: *args: sequence of channel receivers. \"\"\" self . _receivers = { str ( id ): recv for id , recv in enumerate ( args )} self . _pending : Set [ asyncio . Task [ Any ]] = { asyncio . create_task ( recv . receive (), name = name ) for name , recv in self . _receivers . items () } self . _results : Deque [ T ] = deque ( maxlen = len ( self . _receivers )) def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel () async def receive ( self ) -> Optional [ T ]: \"\"\"Wait until there's a message in any of the channels. Returns: The next message that was received, or `None`, if all channels have closed. \"\"\" # we use a while loop to continue to wait for new data, in case the # previous `wait` completed because a channel was closed. while True : if len ( self . _results ) > 0 : return self . _results . popleft () if len ( self . _pending ) == 0 : return None done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () result = item . result () # if channel is closed, don't add a task for it again. if result is None : continue self . _results . append ( result ) self . _pending . add ( asyncio . create_task ( self . _receivers [ name ] . receive (), name = name ) ) Functions \u00a4 __del__ () \u00a4 Cleanup any pending tasks. Source code in frequenz/channels/merge.py 42 43 44 45 def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel () __init__ ( * args ) \u00a4 Create a Merge instance. PARAMETER DESCRIPTION *args sequence of channel receivers. TYPE: Receiver [ T ] DEFAULT: () Source code in frequenz/channels/merge.py 29 30 31 32 33 34 35 36 37 38 39 40 def __init__ ( self , * args : Receiver [ T ]) -> None : \"\"\"Create a `Merge` instance. Args: *args: sequence of channel receivers. \"\"\" self . _receivers = { str ( id ): recv for id , recv in enumerate ( args )} self . _pending : Set [ asyncio . Task [ Any ]] = { asyncio . create_task ( recv . receive (), name = name ) for name , recv in self . _receivers . items () } self . _results : Deque [ T ] = deque ( maxlen = len ( self . _receivers )) receive () async \u00a4 Wait until there's a message in any of the channels. RETURNS DESCRIPTION Optional [ T ] The next message that was received, or None , if all channels have closed. Source code in frequenz/channels/merge.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 async def receive ( self ) -> Optional [ T ]: \"\"\"Wait until there's a message in any of the channels. Returns: The next message that was received, or `None`, if all channels have closed. \"\"\" # we use a while loop to continue to wait for new data, in case the # previous `wait` completed because a channel was closed. while True : if len ( self . _results ) > 0 : return self . _results . popleft () if len ( self . _pending ) == 0 : return None done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () result = item . result () # if channel is closed, don't add a task for it again. if result is None : continue self . _results . append ( result ) self . _pending . add ( asyncio . create_task ( self . _receivers [ name ] . receive (), name = name ) ) frequenz.channels.MergeNamed \u00a4 Bases: Receiver [ Tuple [ str , T ]] Merge messages coming from multiple named channels into a single stream. Source code in frequenz/channels/merge_named.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class MergeNamed ( Receiver [ Tuple [ str , T ]]): \"\"\"Merge messages coming from multiple named channels into a single stream.\"\"\" def __init__ ( self , ** kwargs : Receiver [ T ]) -> None : \"\"\"Create a `MergeNamed` instance. Args: **kwargs: sequence of channel receivers. \"\"\" self . _receivers = kwargs self . _pending : Set [ asyncio . Task [ Any ]] = { asyncio . create_task ( recv . receive (), name = name ) for name , recv in self . _receivers . items () } self . _results : Deque [ Tuple [ str , T ]] = deque ( maxlen = len ( self . _receivers )) def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel () async def receive ( self ) -> Optional [ Tuple [ str , T ]]: \"\"\"Wait until there's a message in any of the channels. Returns: The next message that was received, or `None`, if all channels have closed. \"\"\" # we use a while loop to continue to wait for new data, in case the # previous `wait` completed because a channel was closed. while True : if len ( self . _results ) > 0 : return self . _results . popleft () if len ( self . _pending ) == 0 : return None done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () result = item . result () # if channel is closed, don't add a task for it again. if result is None : continue self . _results . append (( name , result )) self . _pending . add ( asyncio . create_task ( self . _receivers [ name ] . receive (), name = name ) ) Functions \u00a4 __del__ () \u00a4 Cleanup any pending tasks. Source code in frequenz/channels/merge_named.py 29 30 31 32 def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel () __init__ ( ** kwargs ) \u00a4 Create a MergeNamed instance. PARAMETER DESCRIPTION **kwargs sequence of channel receivers. TYPE: Receiver [ T ] DEFAULT: {} Source code in frequenz/channels/merge_named.py 16 17 18 19 20 21 22 23 24 25 26 27 def __init__ ( self , ** kwargs : Receiver [ T ]) -> None : \"\"\"Create a `MergeNamed` instance. Args: **kwargs: sequence of channel receivers. \"\"\" self . _receivers = kwargs self . _pending : Set [ asyncio . Task [ Any ]] = { asyncio . create_task ( recv . receive (), name = name ) for name , recv in self . _receivers . items () } self . _results : Deque [ Tuple [ str , T ]] = deque ( maxlen = len ( self . _receivers )) receive () async \u00a4 Wait until there's a message in any of the channels. RETURNS DESCRIPTION Optional [ Tuple [ str , T ]] The next message that was received, or None , if all channels have closed. Source code in frequenz/channels/merge_named.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 async def receive ( self ) -> Optional [ Tuple [ str , T ]]: \"\"\"Wait until there's a message in any of the channels. Returns: The next message that was received, or `None`, if all channels have closed. \"\"\" # we use a while loop to continue to wait for new data, in case the # previous `wait` completed because a channel was closed. while True : if len ( self . _results ) > 0 : return self . _results . popleft () if len ( self . _pending ) == 0 : return None done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () result = item . result () # if channel is closed, don't add a task for it again. if result is None : continue self . _results . append (( name , result )) self . _pending . add ( asyncio . create_task ( self . _receivers [ name ] . receive (), name = name ) ) frequenz.channels.Peekable \u00a4 Bases: ABC , Generic [ T ] A channel peekable. A Peekable provides a peek() method that allows the user to get a peek at the latest value in the channel, without consuming anything. Source code in frequenz/channels/base_classes.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 class Peekable ( ABC , Generic [ T ]): \"\"\"A channel peekable. A Peekable provides a [peek()][frequenz.channels.Peekable] method that allows the user to get a peek at the latest value in the channel, without consuming anything. \"\"\" @abstractmethod def peek ( self ) -> Optional [ T ]: \"\"\"Return the latest value that was sent to the channel. Returns: The latest value received by the channel, and `None`, if nothing has been sent to the channel yet. \"\"\" Functions \u00a4 peek () abstractmethod \u00a4 Return the latest value that was sent to the channel. RETURNS DESCRIPTION Optional [ T ] The latest value received by the channel, and None , if nothing has been sent to the channel yet. Source code in frequenz/channels/base_classes.py 97 98 99 100 101 102 103 104 @abstractmethod def peek ( self ) -> Optional [ T ]: \"\"\"Return the latest value that was sent to the channel. Returns: The latest value received by the channel, and `None`, if nothing has been sent to the channel yet. \"\"\" frequenz.channels.Receiver \u00a4 Bases: ABC , Generic [ T ] A channel Receiver. Source code in frequenz/channels/base_classes.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class Receiver ( ABC , Generic [ T ]): \"\"\"A channel Receiver.\"\"\" @abstractmethod async def receive ( self ) -> Optional [ T ]: \"\"\"Receive a message from the channel. Returns: `None`, if the channel is closed, a message otherwise. \"\"\" def __aiter__ ( self ) -> Receiver [ T ]: \"\"\"Initialize the async iterator over received values. Returns: `self`, since no extra setup is needed for the iterator. \"\"\" return self async def __anext__ ( self ) -> T : \"\"\"Await the next value in the async iteration over received values. Returns: The next value received. Raises: StopAsyncIteration: if we receive `None`, i.e. if the underlying channel is closed. \"\"\" received = await self . receive () if received is None : raise StopAsyncIteration return received def map ( self , call : Callable [[ T ], U ]) -> Receiver [ U ]: \"\"\"Return a receiver with `call` applied on incoming messages. Args: call: function to apply on incoming messages. Returns: A `Receiver` to read results of the given function from. \"\"\" return _Map ( self , call ) def into_peekable ( self ) -> Peekable [ T ]: \"\"\"Convert the `Receiver` implementation into a `Peekable`. Once this function has been called, the receiver will no longer be usable, and calling `receive` on the receiver will raise an exception. Raises: NotImplementedError: when a `Receiver` implementation doesn't have a custom `get_peekable` implementation. \"\"\" raise NotImplementedError ( \"This receiver does not implement `into_peekable`\" ) Functions \u00a4 __aiter__ () \u00a4 Initialize the async iterator over received values. RETURNS DESCRIPTION Receiver [ T ] self , since no extra setup is needed for the iterator. Source code in frequenz/channels/base_classes.py 42 43 44 45 46 47 48 def __aiter__ ( self ) -> Receiver [ T ]: \"\"\"Initialize the async iterator over received values. Returns: `self`, since no extra setup is needed for the iterator. \"\"\" return self __anext__ () async \u00a4 Await the next value in the async iteration over received values. RETURNS DESCRIPTION T The next value received. RAISES DESCRIPTION StopAsyncIteration if we receive None , i.e. if the underlying channel is closed. Source code in frequenz/channels/base_classes.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 async def __anext__ ( self ) -> T : \"\"\"Await the next value in the async iteration over received values. Returns: The next value received. Raises: StopAsyncIteration: if we receive `None`, i.e. if the underlying channel is closed. \"\"\" received = await self . receive () if received is None : raise StopAsyncIteration return received into_peekable () \u00a4 Convert the Receiver implementation into a Peekable . Once this function has been called, the receiver will no longer be usable, and calling receive on the receiver will raise an exception. RAISES DESCRIPTION NotImplementedError when a Receiver implementation doesn't have a custom get_peekable implementation. Source code in frequenz/channels/base_classes.py 76 77 78 79 80 81 82 83 84 85 86 def into_peekable ( self ) -> Peekable [ T ]: \"\"\"Convert the `Receiver` implementation into a `Peekable`. Once this function has been called, the receiver will no longer be usable, and calling `receive` on the receiver will raise an exception. Raises: NotImplementedError: when a `Receiver` implementation doesn't have a custom `get_peekable` implementation. \"\"\" raise NotImplementedError ( \"This receiver does not implement `into_peekable`\" ) map ( call ) \u00a4 Return a receiver with call applied on incoming messages. PARAMETER DESCRIPTION call function to apply on incoming messages. TYPE: Callable [[ T ], U ] RETURNS DESCRIPTION Receiver [ U ] A Receiver to read results of the given function from. Source code in frequenz/channels/base_classes.py 65 66 67 68 69 70 71 72 73 74 def map ( self , call : Callable [[ T ], U ]) -> Receiver [ U ]: \"\"\"Return a receiver with `call` applied on incoming messages. Args: call: function to apply on incoming messages. Returns: A `Receiver` to read results of the given function from. \"\"\" return _Map ( self , call ) receive () async abstractmethod \u00a4 Receive a message from the channel. RETURNS DESCRIPTION Optional [ T ] None , if the channel is closed, a message otherwise. Source code in frequenz/channels/base_classes.py 34 35 36 37 38 39 40 @abstractmethod async def receive ( self ) -> Optional [ T ]: \"\"\"Receive a message from the channel. Returns: `None`, if the channel is closed, a message otherwise. \"\"\" frequenz.channels.Select \u00a4 Select the next available message from a group of AsyncIterators. If Select was created with more AsyncIterator than what are read in the if-chain after each call to ready() , messages coming in the additional async iterators are dropped, and a warning message is logged. Receiver s also function as AsyncIterator . Example For example, if there are two async iterators that you want to simultaneously wait on, this can be done with: select = Select ( name1 = receiver1 , name2 = receiver2 ) while await select . ready (): if msg := select . name1 : if val := msg . inner : # do something with `val` pass else : # handle closure of receiver. pass elif msg := select . name2 : # do something with `msg.inner` pass Source code in frequenz/channels/select.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class Select : \"\"\"Select the next available message from a group of AsyncIterators. If `Select` was created with more `AsyncIterator` than what are read in the if-chain after each call to [ready()][frequenz.channels.Select.ready], messages coming in the additional async iterators are dropped, and a warning message is logged. [Receiver][frequenz.channels.Receiver]s also function as `AsyncIterator`. Example: For example, if there are two async iterators that you want to simultaneously wait on, this can be done with: ```python select = Select(name1 = receiver1, name2 = receiver2) while await select.ready(): if msg := select.name1: if val := msg.inner: # do something with `val` pass else: # handle closure of receiver. pass elif msg := select.name2: # do something with `msg.inner` pass ``` \"\"\" def __init__ ( self , ** kwargs : AsyncIterator [ Any ]) -> None : \"\"\"Create a `Select` instance. Args: **kwargs: sequence of async iterators \"\"\" self . _receivers = kwargs self . _pending : Set [ asyncio . Task [ Any ]] = set () for name , recv in self . _receivers . items (): # can replace __anext__() to anext() (Only Python 3.10>=) msg = recv . __anext__ () # pylint: disable=unnecessary-dunder-call self . _pending . add ( asyncio . create_task ( msg , name = name )) # type: ignore self . _ready_count = 0 self . _prev_ready_count = 0 self . _result : Dict [ str , Optional [ _Selected ]] = { name : None for name in self . _receivers } def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel () async def ready ( self ) -> bool : \"\"\"Wait until there is a message in any of the async iterators. Returns `True` if there is a message available, and `False` if all async iterators have closed. Returns: Whether there are further messages or not. \"\"\" if self . _ready_count > 0 : if self . _ready_count == self . _prev_ready_count : dropped_names : List [ str ] = [] for name , value in self . _result . items (): if value is not None : dropped_names . append ( name ) self . _result [ name ] = None self . _ready_count = 0 self . _prev_ready_count = 0 logger . warning ( \"Select.ready() dropped data from async iterator(s): %s , \" \"because no messages have been fetched since the last call to ready().\" , dropped_names , ) else : self . _prev_ready_count = self . _ready_count return True if len ( self . _pending ) == 0 : return False # once all the pending messages have been consumed, reset the # `_prev_ready_count` as well, and wait for new messages. self . _prev_ready_count = 0 done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () if isinstance ( item . exception (), StopAsyncIteration ): result = None else : result = item . result () self . _ready_count += 1 self . _result [ name ] = _Selected ( result ) # if channel or AsyncIterator is closed # don't add a task for it again. if result is None : continue msg = self . _receivers [ # pylint: disable=unnecessary-dunder-call name ] . __anext__ () self . _pending . add ( asyncio . create_task ( msg , name = name )) # type: ignore return True def __getattr__ ( self , name : str ) -> Optional [ Any ]: \"\"\"Return the latest unread message from a `AsyncIterator`, if available. Args: name: Name of the channel. Returns: Latest unread message for the specified `AsyncIterator`, or `None`. Raises: KeyError: when the name was not specified when creating the `Select` instance. \"\"\" result = self . _result [ name ] if result is None : return result self . _result [ name ] = None self . _ready_count -= 1 return result Functions \u00a4 __del__ () \u00a4 Cleanup any pending tasks. Source code in frequenz/channels/select.py 81 82 83 84 def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel () __getattr__ ( name ) \u00a4 Return the latest unread message from a AsyncIterator , if available. PARAMETER DESCRIPTION name Name of the channel. TYPE: str RETURNS DESCRIPTION Optional [ Any ] Latest unread message for the specified AsyncIterator , or None . RAISES DESCRIPTION KeyError when the name was not specified when creating the Select instance. Source code in frequenz/channels/select.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def __getattr__ ( self , name : str ) -> Optional [ Any ]: \"\"\"Return the latest unread message from a `AsyncIterator`, if available. Args: name: Name of the channel. Returns: Latest unread message for the specified `AsyncIterator`, or `None`. Raises: KeyError: when the name was not specified when creating the `Select` instance. \"\"\" result = self . _result [ name ] if result is None : return result self . _result [ name ] = None self . _ready_count -= 1 return result __init__ ( ** kwargs ) \u00a4 Create a Select instance. PARAMETER DESCRIPTION **kwargs sequence of async iterators TYPE: AsyncIterator [ Any ] DEFAULT: {} Source code in frequenz/channels/select.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def __init__ ( self , ** kwargs : AsyncIterator [ Any ]) -> None : \"\"\"Create a `Select` instance. Args: **kwargs: sequence of async iterators \"\"\" self . _receivers = kwargs self . _pending : Set [ asyncio . Task [ Any ]] = set () for name , recv in self . _receivers . items (): # can replace __anext__() to anext() (Only Python 3.10>=) msg = recv . __anext__ () # pylint: disable=unnecessary-dunder-call self . _pending . add ( asyncio . create_task ( msg , name = name )) # type: ignore self . _ready_count = 0 self . _prev_ready_count = 0 self . _result : Dict [ str , Optional [ _Selected ]] = { name : None for name in self . _receivers } ready () async \u00a4 Wait until there is a message in any of the async iterators. Returns True if there is a message available, and False if all async iterators have closed. RETURNS DESCRIPTION bool Whether there are further messages or not. Source code in frequenz/channels/select.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 async def ready ( self ) -> bool : \"\"\"Wait until there is a message in any of the async iterators. Returns `True` if there is a message available, and `False` if all async iterators have closed. Returns: Whether there are further messages or not. \"\"\" if self . _ready_count > 0 : if self . _ready_count == self . _prev_ready_count : dropped_names : List [ str ] = [] for name , value in self . _result . items (): if value is not None : dropped_names . append ( name ) self . _result [ name ] = None self . _ready_count = 0 self . _prev_ready_count = 0 logger . warning ( \"Select.ready() dropped data from async iterator(s): %s , \" \"because no messages have been fetched since the last call to ready().\" , dropped_names , ) else : self . _prev_ready_count = self . _ready_count return True if len ( self . _pending ) == 0 : return False # once all the pending messages have been consumed, reset the # `_prev_ready_count` as well, and wait for new messages. self . _prev_ready_count = 0 done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () if isinstance ( item . exception (), StopAsyncIteration ): result = None else : result = item . result () self . _ready_count += 1 self . _result [ name ] = _Selected ( result ) # if channel or AsyncIterator is closed # don't add a task for it again. if result is None : continue msg = self . _receivers [ # pylint: disable=unnecessary-dunder-call name ] . __anext__ () self . _pending . add ( asyncio . create_task ( msg , name = name )) # type: ignore return True frequenz.channels.Sender \u00a4 Bases: ABC , Generic [ T ] A channel Sender. Source code in frequenz/channels/base_classes.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Sender ( ABC , Generic [ T ]): \"\"\"A channel Sender.\"\"\" @abstractmethod async def send ( self , msg : T ) -> bool : \"\"\"Send a message to the channel. Args: msg: The message to be sent. Returns: Whether the message was sent, based on whether the channel is open or not. \"\"\" Functions \u00a4 send ( msg ) async abstractmethod \u00a4 Send a message to the channel. PARAMETER DESCRIPTION msg The message to be sent. TYPE: T RETURNS DESCRIPTION bool Whether the message was sent, based on whether the channel is open or not. Source code in frequenz/channels/base_classes.py 18 19 20 21 22 23 24 25 26 27 28 @abstractmethod async def send ( self , msg : T ) -> bool : \"\"\"Send a message to the channel. Args: msg: The message to be sent. Returns: Whether the message was sent, based on whether the channel is open or not. \"\"\" frequenz.channels.Timer \u00a4 Bases: Receiver [ datetime ] A timer receiver that returns the timestamp every interval seconds. Primarily for use with Select . Example When you want something to happen with a fixed period: timer = channel . Timer ( 30.0 ) select = Select ( bat_1 = receiver1 , timer = timer ) while await select . ready (): if msg := select . bat_1 : if val := msg . inner : process_data ( val ) else : logging . warn ( \"battery channel closed\" ) if ts := select . timer : # something to do once every 30 seconds pass When you want something to happen when nothing else has happened in a certain interval: timer = channel . Timer ( 30.0 ) select = Select ( bat_1 = receiver1 , timer = timer ) while await select . ready (): timer . reset () if msg := select . bat_1 : if val := msg . inner : process_data ( val ) else : logging . warn ( \"battery channel closed\" ) if ts := select . timer : # something to do if there's no battery data for 30 seconds pass Source code in frequenz/channels/utils/timer.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class Timer ( Receiver [ datetime ]): \"\"\"A timer receiver that returns the timestamp every `interval` seconds. Primarily for use with [Select][frequenz.channels.Select]. Example: When you want something to happen with a fixed period: ```python timer = channel.Timer(30.0) select = Select(bat_1 = receiver1, timer = timer) while await select.ready(): if msg := select.bat_1: if val := msg.inner: process_data(val) else: logging.warn(\"battery channel closed\") if ts := select.timer: # something to do once every 30 seconds pass ``` When you want something to happen when nothing else has happened in a certain interval: ```python timer = channel.Timer(30.0) select = Select(bat_1 = receiver1, timer = timer) while await select.ready(): timer.reset() if msg := select.bat_1: if val := msg.inner: process_data(val) else: logging.warn(\"battery channel closed\") if ts := select.timer: # something to do if there's no battery data for 30 seconds pass ``` \"\"\" def __init__ ( self , interval : float ) -> None : \"\"\"Create a `Timer` instance. Args: interval: number of seconds between messages. \"\"\" self . _stopped = False self . _interval = timedelta ( seconds = interval ) self . _next_msg_time = datetime . now () + self . _interval def reset ( self ) -> None : \"\"\"Reset the timer to start timing from `now`.\"\"\" self . _next_msg_time = datetime . now () + self . _interval def stop ( self ) -> None : \"\"\"Stop the timer. Once `stop` has been called, all subsequent calls to [receive()][frequenz.channels.Timer.receive] will immediately return `None`. \"\"\" self . _stopped = True async def receive ( self ) -> Optional [ datetime ]: \"\"\"Return the current time once the next tick is due. Returns: The time of the next tick or `None` if [stop()][frequenz.channels.Timer.stop] has been called on the timer. \"\"\" if self . _stopped : return None now = datetime . now () diff = self . _next_msg_time - now while diff . total_seconds () > 0 : await asyncio . sleep ( diff . total_seconds ()) now = datetime . now () diff = self . _next_msg_time - now self . _next_msg_time = now + self . _interval return now Functions \u00a4 __init__ ( interval ) \u00a4 Create a Timer instance. PARAMETER DESCRIPTION interval number of seconds between messages. TYPE: float Source code in frequenz/channels/utils/timer.py 54 55 56 57 58 59 60 61 62 def __init__ ( self , interval : float ) -> None : \"\"\"Create a `Timer` instance. Args: interval: number of seconds between messages. \"\"\" self . _stopped = False self . _interval = timedelta ( seconds = interval ) self . _next_msg_time = datetime . now () + self . _interval receive () async \u00a4 Return the current time once the next tick is due. RETURNS DESCRIPTION Optional [ datetime ] The time of the next tick or None if stop() has been called on the timer. Source code in frequenz/channels/utils/timer.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 async def receive ( self ) -> Optional [ datetime ]: \"\"\"Return the current time once the next tick is due. Returns: The time of the next tick or `None` if [stop()][frequenz.channels.Timer.stop] has been called on the timer. \"\"\" if self . _stopped : return None now = datetime . now () diff = self . _next_msg_time - now while diff . total_seconds () > 0 : await asyncio . sleep ( diff . total_seconds ()) now = datetime . now () diff = self . _next_msg_time - now self . _next_msg_time = now + self . _interval return now reset () \u00a4 Reset the timer to start timing from now . Source code in frequenz/channels/utils/timer.py 64 65 66 def reset ( self ) -> None : \"\"\"Reset the timer to start timing from `now`.\"\"\" self . _next_msg_time = datetime . now () + self . _interval stop () \u00a4 Stop the timer. Once stop has been called, all subsequent calls to receive() will immediately return None . Source code in frequenz/channels/utils/timer.py 68 69 70 71 72 73 74 75 def stop ( self ) -> None : \"\"\"Stop the timer. Once `stop` has been called, all subsequent calls to [receive()][frequenz.channels.Timer.receive] will immediately return `None`. \"\"\" self . _stopped = True","title":"channels"},{"location":"reference/frequenz/channels/#frequenz.channels","text":"Channel implementations.","title":"channels"},{"location":"reference/frequenz/channels/#frequenz.channels-classes","text":"","title":"Classes"},{"location":"reference/frequenz/channels/#frequenz.channels.Anycast","text":"Bases: Generic [ T ] A channel for sending data across async tasks. Anycast channels support multiple senders and multiple receivers. A message sent through a sender will be received by exactly one receiver. In cases where each message need to be received by every receiver, a Broadcast channel may be used. Uses an deque internally, so Anycast channels are not thread-safe. When there are multiple channel receivers, they can be awaited simultaneously using Select , Merge or MergeNamed . Example async def send ( sender : channel . Sender ) -> None : while True : next = random . randint ( 3 , 17 ) print ( f \"sending: { next } \" ) await sender . send ( next ) async def recv ( id : int , receiver : channel . Receiver ) -> None : while True : next = await receiver . receive () print ( f \"receiver_ { id } received { next } \" ) await asyncio . sleep ( 0.1 ) # sleep (or work) with the data acast = channel . Anycast () sender = acast . get_sender () receiver_1 = acast . get_receiver () asyncio . create_task ( send ( sender )) await recv ( 1 , receiver_1 ) Check the tests and benchmarks directories for more examples. Source code in frequenz/channels/anycast.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 class Anycast ( Generic [ T ]): \"\"\"A channel for sending data across async tasks. Anycast channels support multiple senders and multiple receivers. A message sent through a sender will be received by exactly one receiver. In cases where each message need to be received by every receiver, a [Broadcast][frequenz.channels.Broadcast] channel may be used. Uses an [deque][collections.deque] internally, so Anycast channels are not thread-safe. When there are multiple channel receivers, they can be awaited simultaneously using [Select][frequenz.channels.Select], [Merge][frequenz.channels.Merge] or [MergeNamed][frequenz.channels.MergeNamed]. Example: ``` python async def send(sender: channel.Sender) -> None: while True: next = random.randint(3, 17) print(f\"sending: {next}\") await sender.send(next) async def recv(id: int, receiver: channel.Receiver) -> None: while True: next = await receiver.receive() print(f\"receiver_{id} received {next}\") await asyncio.sleep(0.1) # sleep (or work) with the data acast = channel.Anycast() sender = acast.get_sender() receiver_1 = acast.get_receiver() asyncio.create_task(send(sender)) await recv(1, receiver_1) ``` Check the `tests` and `benchmarks` directories for more examples. \"\"\" def __init__ ( self , maxsize : int = 10 ) -> None : \"\"\"Create an Anycast channel. Args: maxsize: Size of the channel's buffer. \"\"\" self . limit : int = maxsize self . deque : Deque [ T ] = deque ( maxlen = maxsize ) self . send_cv : Condition = Condition () self . recv_cv : Condition = Condition () self . closed : bool = False async def close ( self ) -> None : \"\"\"Close the channel. Any further attempts to [send()][frequenz.channels.Sender.send] data will return `False`. Receivers will still be able to drain the pending items on the channel, but after that, subsequent [receive()][frequenz.channels.Receiver.receive] calls will return `None` immediately. \"\"\" self . closed = True async with self . send_cv : self . send_cv . notify_all () async with self . recv_cv : self . recv_cv . notify_all () def get_sender ( self ) -> Sender [ T ]: \"\"\"Create a new sender. Returns: A Sender instance attached to the Anycast channel. \"\"\" return Sender ( self ) def get_receiver ( self ) -> Receiver [ T ]: \"\"\"Create a new receiver. Returns: A Receiver instance attached to the Anycast channel. \"\"\" return Receiver ( self )","title":"Anycast"},{"location":"reference/frequenz/channels/#frequenz.channels.Anycast-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/#frequenz.channels.anycast.Anycast.__init__","text":"Create an Anycast channel. PARAMETER DESCRIPTION maxsize Size of the channel's buffer. TYPE: int DEFAULT: 10 Source code in frequenz/channels/anycast.py 63 64 65 66 67 68 69 70 71 72 73 def __init__ ( self , maxsize : int = 10 ) -> None : \"\"\"Create an Anycast channel. Args: maxsize: Size of the channel's buffer. \"\"\" self . limit : int = maxsize self . deque : Deque [ T ] = deque ( maxlen = maxsize ) self . send_cv : Condition = Condition () self . recv_cv : Condition = Condition () self . closed : bool = False","title":"__init__()"},{"location":"reference/frequenz/channels/#frequenz.channels.anycast.Anycast.close","text":"Close the channel. Any further attempts to send() data will return False . Receivers will still be able to drain the pending items on the channel, but after that, subsequent receive() calls will return None immediately. Source code in frequenz/channels/anycast.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 async def close ( self ) -> None : \"\"\"Close the channel. Any further attempts to [send()][frequenz.channels.Sender.send] data will return `False`. Receivers will still be able to drain the pending items on the channel, but after that, subsequent [receive()][frequenz.channels.Receiver.receive] calls will return `None` immediately. \"\"\" self . closed = True async with self . send_cv : self . send_cv . notify_all () async with self . recv_cv : self . recv_cv . notify_all ()","title":"close()"},{"location":"reference/frequenz/channels/#frequenz.channels.anycast.Anycast.get_receiver","text":"Create a new receiver. RETURNS DESCRIPTION Receiver [ T ] A Receiver instance attached to the Anycast channel. Source code in frequenz/channels/anycast.py 101 102 103 104 105 106 107 def get_receiver ( self ) -> Receiver [ T ]: \"\"\"Create a new receiver. Returns: A Receiver instance attached to the Anycast channel. \"\"\" return Receiver ( self )","title":"get_receiver()"},{"location":"reference/frequenz/channels/#frequenz.channels.anycast.Anycast.get_sender","text":"Create a new sender. RETURNS DESCRIPTION Sender [ T ] A Sender instance attached to the Anycast channel. Source code in frequenz/channels/anycast.py 93 94 95 96 97 98 99 def get_sender ( self ) -> Sender [ T ]: \"\"\"Create a new sender. Returns: A Sender instance attached to the Anycast channel. \"\"\" return Sender ( self )","title":"get_sender()"},{"location":"reference/frequenz/channels/#frequenz.channels.Bidirectional","text":"Bases: Generic [ T , U ] A wrapper class for simulating bidirectional channels. Source code in frequenz/channels/bidirectional.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Bidirectional ( Generic [ T , U ]): \"\"\"A wrapper class for simulating bidirectional channels.\"\"\" def __init__ ( self , client_id : str , service_id : str ) -> None : \"\"\"Create a `Bidirectional` instance. Args: client_id: A name for the client, used to name the channels. service_id: A name for the service end of the channels. \"\"\" self . _client_id = client_id self . _request_channel : Broadcast [ T ] = Broadcast ( f \"req_ { service_id } _ { client_id } \" ) self . _response_channel : Broadcast [ U ] = Broadcast ( f \"resp_ { service_id } _ { client_id } \" ) self . _client_handle = BidirectionalHandle ( self . _request_channel . get_sender (), self . _response_channel . get_receiver (), ) self . _service_handle = BidirectionalHandle ( self . _response_channel . get_sender (), self . _request_channel . get_receiver (), ) @property def client_handle ( self ) -> BidirectionalHandle [ T , U ]: \"\"\"Get a BidirectionalHandle for the client to use. Returns: Object to send/receive messages with. \"\"\" return self . _client_handle @property def service_handle ( self ) -> BidirectionalHandle [ U , T ]: \"\"\"Get a `BidirectionalHandle` for the service to use. Returns: Object to send/receive messages with. \"\"\" return self . _service_handle","title":"Bidirectional"},{"location":"reference/frequenz/channels/#frequenz.channels.Bidirectional-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/#frequenz.channels.bidirectional.Bidirectional.__init__","text":"Create a Bidirectional instance. PARAMETER DESCRIPTION client_id A name for the client, used to name the channels. TYPE: str service_id A name for the service end of the channels. TYPE: str Source code in frequenz/channels/bidirectional.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , client_id : str , service_id : str ) -> None : \"\"\"Create a `Bidirectional` instance. Args: client_id: A name for the client, used to name the channels. service_id: A name for the service end of the channels. \"\"\" self . _client_id = client_id self . _request_channel : Broadcast [ T ] = Broadcast ( f \"req_ { service_id } _ { client_id } \" ) self . _response_channel : Broadcast [ U ] = Broadcast ( f \"resp_ { service_id } _ { client_id } \" ) self . _client_handle = BidirectionalHandle ( self . _request_channel . get_sender (), self . _response_channel . get_receiver (), ) self . _service_handle = BidirectionalHandle ( self . _response_channel . get_sender (), self . _request_channel . get_receiver (), )","title":"__init__()"},{"location":"reference/frequenz/channels/#frequenz.channels.bidirectional.Bidirectional.client_handle","text":"Get a BidirectionalHandle for the client to use. RETURNS DESCRIPTION BidirectionalHandle [ T , U ] Object to send/receive messages with. Source code in frequenz/channels/bidirectional.py 39 40 41 42 43 44 45 46 @property def client_handle ( self ) -> BidirectionalHandle [ T , U ]: \"\"\"Get a BidirectionalHandle for the client to use. Returns: Object to send/receive messages with. \"\"\" return self . _client_handle","title":"client_handle()"},{"location":"reference/frequenz/channels/#frequenz.channels.bidirectional.Bidirectional.service_handle","text":"Get a BidirectionalHandle for the service to use. RETURNS DESCRIPTION BidirectionalHandle [ U , T ] Object to send/receive messages with. Source code in frequenz/channels/bidirectional.py 48 49 50 51 52 53 54 55 @property def service_handle ( self ) -> BidirectionalHandle [ U , T ]: \"\"\"Get a `BidirectionalHandle` for the service to use. Returns: Object to send/receive messages with. \"\"\" return self . _service_handle","title":"service_handle()"},{"location":"reference/frequenz/channels/#frequenz.channels.BidirectionalHandle","text":"Bases: Sender [ T ] , Receiver [ U ] A handle to a Bidirectional instance. It can be used to send/receive values between the client and service. Source code in frequenz/channels/bidirectional.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class BidirectionalHandle ( Sender [ T ], Receiver [ U ]): \"\"\"A handle to a [Bidirectional][frequenz.channels.Bidirectional] instance. It can be used to send/receive values between the client and service. \"\"\" def __init__ ( self , sender : Sender [ T ], receiver : Receiver [ U ]) -> None : \"\"\"Create a `BidirectionalHandle` instance. Args: sender: A sender to send values with. receiver: A receiver to receive values from. \"\"\" self . _sender = sender self . _receiver = receiver async def send ( self , msg : T ) -> bool : \"\"\"Send a value to the other side. Args: msg: The value to send. Returns: Whether the send was successful or not. \"\"\" return await self . _sender . send ( msg ) async def receive ( self ) -> Optional [ U ]: \"\"\"Receive a value from the other side. Returns: Received value, or `None` if the channels are closed. \"\"\" return await self . _receiver . receive ()","title":"BidirectionalHandle"},{"location":"reference/frequenz/channels/#frequenz.channels.BidirectionalHandle-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/#frequenz.channels.bidirectional.BidirectionalHandle.__init__","text":"Create a BidirectionalHandle instance. PARAMETER DESCRIPTION sender A sender to send values with. TYPE: Sender [ T ] receiver A receiver to receive values from. TYPE: Receiver [ U ] Source code in frequenz/channels/bidirectional.py 64 65 66 67 68 69 70 71 72 def __init__ ( self , sender : Sender [ T ], receiver : Receiver [ U ]) -> None : \"\"\"Create a `BidirectionalHandle` instance. Args: sender: A sender to send values with. receiver: A receiver to receive values from. \"\"\" self . _sender = sender self . _receiver = receiver","title":"__init__()"},{"location":"reference/frequenz/channels/#frequenz.channels.bidirectional.BidirectionalHandle.receive","text":"Receive a value from the other side. RETURNS DESCRIPTION Optional [ U ] Received value, or None if the channels are closed. Source code in frequenz/channels/bidirectional.py 85 86 87 88 89 90 91 async def receive ( self ) -> Optional [ U ]: \"\"\"Receive a value from the other side. Returns: Received value, or `None` if the channels are closed. \"\"\" return await self . _receiver . receive ()","title":"receive()"},{"location":"reference/frequenz/channels/#frequenz.channels.bidirectional.BidirectionalHandle.send","text":"Send a value to the other side. PARAMETER DESCRIPTION msg The value to send. TYPE: T RETURNS DESCRIPTION bool Whether the send was successful or not. Source code in frequenz/channels/bidirectional.py 74 75 76 77 78 79 80 81 82 83 async def send ( self , msg : T ) -> bool : \"\"\"Send a value to the other side. Args: msg: The value to send. Returns: Whether the send was successful or not. \"\"\" return await self . _sender . send ( msg )","title":"send()"},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast","text":"Bases: Generic [ T ] A channel to broadcast messages to multiple receivers. Broadcast channels can have multiple senders and multiple receivers. Each message sent through any of the senders is received by all of the receivers. Internally, a broadcast receiver's buffer is implemented with just append/pop operations on either side of a deque , which are thread-safe. Because of this, Broadcast channels are thread-safe. When there are multiple channel receivers, they can be awaited simultaneously using Select , Merge or MergeNamed . Example async def send ( sender : channel . Sender ) -> None : while True : next = random . randint ( 3 , 17 ) print ( f \"sending: { next } \" ) await sender . send ( next ) async def recv ( id : int , receiver : channel . Receiver ) -> None : while True : next = await receiver . receive () print ( f \"receiver_ { id } received { next } \" ) await asyncio . sleep ( 0.1 ) # sleep (or work) with the data bcast = channel . Broadcast () sender = bcast . get_sender () receiver_1 = bcast . get_receiver () asyncio . create_task ( send ( sender )) await recv ( 1 , receiver_1 ) Check the tests and benchmarks directories for more examples. Source code in frequenz/channels/broadcast.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class Broadcast ( Generic [ T ]): \"\"\"A channel to broadcast messages to multiple receivers. `Broadcast` channels can have multiple senders and multiple receivers. Each message sent through any of the senders is received by all of the receivers. Internally, a broadcast receiver's buffer is implemented with just append/pop operations on either side of a [deque][collections.deque], which are thread-safe. Because of this, `Broadcast` channels are thread-safe. When there are multiple channel receivers, they can be awaited simultaneously using [Select][frequenz.channels.Select], [Merge][frequenz.channels.Merge] or [MergeNamed][frequenz.channels.MergeNamed]. Example: ``` python async def send(sender: channel.Sender) -> None: while True: next = random.randint(3, 17) print(f\"sending: {next}\") await sender.send(next) async def recv(id: int, receiver: channel.Receiver) -> None: while True: next = await receiver.receive() print(f\"receiver_{id} received {next}\") await asyncio.sleep(0.1) # sleep (or work) with the data bcast = channel.Broadcast() sender = bcast.get_sender() receiver_1 = bcast.get_receiver() asyncio.create_task(send(sender)) await recv(1, receiver_1) ``` Check the `tests` and `benchmarks` directories for more examples. \"\"\" def __init__ ( self , name : str , resend_latest : bool = False ) -> None : \"\"\"Create a Broadcast channel. Args: name: A name for the broadcast channel, typically based on the type of data sent through it. Used to identify the channel in the logs. resend_latest: When True, every time a new receiver is created with `get_receiver`, it will automatically get sent the latest value on the channel. This allows new receivers on slow streams to get the latest value as soon as they are created, without having to wait for the next message on the channel to arrive. \"\"\" self . name : str = name self . _resend_latest = resend_latest self . recv_cv : Condition = Condition () self . receivers : Dict [ UUID , Receiver [ T ]] = {} self . closed : bool = False self . _latest : Optional [ T ] = None async def close ( self ) -> None : \"\"\"Close the Broadcast channel. Any further attempts to [send()][frequenz.channels.Sender.send] data will return `False`. Receivers will still be able to drain the pending items on their queues, but after that, subsequent [receive()][frequenz.channels.Receiver.receive] calls will return `None` immediately. \"\"\" self . _latest = None self . closed = True async with self . recv_cv : self . recv_cv . notify_all () def _drop_receiver ( self , uuid : UUID ) -> None : \"\"\"Drop a specific receiver from the list of broadcast receivers. Called from the destructors of receivers. Args: uuid: a uuid identifying the receiver to be dropped. \"\"\" if uuid in self . receivers : del self . receivers [ uuid ] def get_sender ( self ) -> Sender [ T ]: \"\"\"Create a new broadcast sender. Returns: A Sender instance attached to the broadcast channel. \"\"\" return Sender ( self ) def get_receiver ( self , name : Optional [ str ] = None , maxsize : int = 50 ) -> Receiver [ T ]: \"\"\"Create a new broadcast receiver. Broadcast receivers have their own buffer, and when messages are not being consumed fast enough and the buffer fills up, old messages will get dropped just in this receiver. Args: name: A name to identify the receiver in the logs. maxsize: Size of the receiver's buffer. Returns: A Receiver instance attached to the broadcast channel. \"\"\" uuid = uuid4 () if name is None : name = str ( uuid ) recv : Receiver [ T ] = Receiver ( uuid , name , maxsize , self ) self . receivers [ uuid ] = recv if self . _resend_latest and self . _latest is not None : recv . enqueue ( self . _latest ) return recv def get_peekable ( self ) -> Peekable [ T ]: \"\"\"Create a new Peekable for the broadcast channel. A Peekable provides a [peek()][frequenz.channels.Peekable.peek] method that allows the user to get a peek at the latest value in the channel, without consuming anything. Returns: A Peekable to peek into the broadcast channel with. \"\"\" return Peekable ( self )","title":"Broadcast"},{"location":"reference/frequenz/channels/#frequenz.channels.Broadcast-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/#frequenz.channels.broadcast.Broadcast.__init__","text":"Create a Broadcast channel. PARAMETER DESCRIPTION name A name for the broadcast channel, typically based on the type of data sent through it. Used to identify the channel in the logs. TYPE: str resend_latest When True, every time a new receiver is created with get_receiver , it will automatically get sent the latest value on the channel. This allows new receivers on slow streams to get the latest value as soon as they are created, without having to wait for the next message on the channel to arrive. TYPE: bool DEFAULT: False Source code in frequenz/channels/broadcast.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def __init__ ( self , name : str , resend_latest : bool = False ) -> None : \"\"\"Create a Broadcast channel. Args: name: A name for the broadcast channel, typically based on the type of data sent through it. Used to identify the channel in the logs. resend_latest: When True, every time a new receiver is created with `get_receiver`, it will automatically get sent the latest value on the channel. This allows new receivers on slow streams to get the latest value as soon as they are created, without having to wait for the next message on the channel to arrive. \"\"\" self . name : str = name self . _resend_latest = resend_latest self . recv_cv : Condition = Condition () self . receivers : Dict [ UUID , Receiver [ T ]] = {} self . closed : bool = False self . _latest : Optional [ T ] = None","title":"__init__()"},{"location":"reference/frequenz/channels/#frequenz.channels.broadcast.Broadcast.close","text":"Close the Broadcast channel. Any further attempts to send() data will return False . Receivers will still be able to drain the pending items on their queues, but after that, subsequent receive() calls will return None immediately. Source code in frequenz/channels/broadcast.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 async def close ( self ) -> None : \"\"\"Close the Broadcast channel. Any further attempts to [send()][frequenz.channels.Sender.send] data will return `False`. Receivers will still be able to drain the pending items on their queues, but after that, subsequent [receive()][frequenz.channels.Receiver.receive] calls will return `None` immediately. \"\"\" self . _latest = None self . closed = True async with self . recv_cv : self . recv_cv . notify_all ()","title":"close()"},{"location":"reference/frequenz/channels/#frequenz.channels.broadcast.Broadcast.get_peekable","text":"Create a new Peekable for the broadcast channel. A Peekable provides a peek() method that allows the user to get a peek at the latest value in the channel, without consuming anything. RETURNS DESCRIPTION Peekable [ T ] A Peekable to peek into the broadcast channel with. Source code in frequenz/channels/broadcast.py 148 149 150 151 152 153 154 155 156 157 158 def get_peekable ( self ) -> Peekable [ T ]: \"\"\"Create a new Peekable for the broadcast channel. A Peekable provides a [peek()][frequenz.channels.Peekable.peek] method that allows the user to get a peek at the latest value in the channel, without consuming anything. Returns: A Peekable to peek into the broadcast channel with. \"\"\" return Peekable ( self )","title":"get_peekable()"},{"location":"reference/frequenz/channels/#frequenz.channels.broadcast.Broadcast.get_receiver","text":"Create a new broadcast receiver. Broadcast receivers have their own buffer, and when messages are not being consumed fast enough and the buffer fills up, old messages will get dropped just in this receiver. PARAMETER DESCRIPTION name A name to identify the receiver in the logs. TYPE: Optional [ str ] DEFAULT: None maxsize Size of the receiver's buffer. TYPE: int DEFAULT: 50 RETURNS DESCRIPTION Receiver [ T ] A Receiver instance attached to the broadcast channel. Source code in frequenz/channels/broadcast.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def get_receiver ( self , name : Optional [ str ] = None , maxsize : int = 50 ) -> Receiver [ T ]: \"\"\"Create a new broadcast receiver. Broadcast receivers have their own buffer, and when messages are not being consumed fast enough and the buffer fills up, old messages will get dropped just in this receiver. Args: name: A name to identify the receiver in the logs. maxsize: Size of the receiver's buffer. Returns: A Receiver instance attached to the broadcast channel. \"\"\" uuid = uuid4 () if name is None : name = str ( uuid ) recv : Receiver [ T ] = Receiver ( uuid , name , maxsize , self ) self . receivers [ uuid ] = recv if self . _resend_latest and self . _latest is not None : recv . enqueue ( self . _latest ) return recv","title":"get_receiver()"},{"location":"reference/frequenz/channels/#frequenz.channels.broadcast.Broadcast.get_sender","text":"Create a new broadcast sender. RETURNS DESCRIPTION Sender [ T ] A Sender instance attached to the broadcast channel. Source code in frequenz/channels/broadcast.py 115 116 117 118 119 120 121 def get_sender ( self ) -> Sender [ T ]: \"\"\"Create a new broadcast sender. Returns: A Sender instance attached to the broadcast channel. \"\"\" return Sender ( self )","title":"get_sender()"},{"location":"reference/frequenz/channels/#frequenz.channels.BufferedReceiver","text":"Bases: Receiver [ T ] A channel receiver with a buffer. Source code in frequenz/channels/base_classes.py 107 108 109 110 111 112 113 114 115 116 class BufferedReceiver ( Receiver [ T ]): \"\"\"A channel receiver with a buffer.\"\"\" @abstractmethod def enqueue ( self , msg : T ) -> None : \"\"\"Put a message into this buffered receiver's queue. Args: msg: The message to be added to the queue. \"\"\"","title":"BufferedReceiver"},{"location":"reference/frequenz/channels/#frequenz.channels.BufferedReceiver-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/#frequenz.channels.base_classes.BufferedReceiver.enqueue","text":"Put a message into this buffered receiver's queue. PARAMETER DESCRIPTION msg The message to be added to the queue. TYPE: T Source code in frequenz/channels/base_classes.py 110 111 112 113 114 115 116 @abstractmethod def enqueue ( self , msg : T ) -> None : \"\"\"Put a message into this buffered receiver's queue. Args: msg: The message to be added to the queue. \"\"\"","title":"enqueue()"},{"location":"reference/frequenz/channels/#frequenz.channels.FileWatcher","text":"Bases: Receiver [ pathlib . Path ] A channel receiver that watches for file events. Source code in frequenz/channels/utils/file_watcher.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class FileWatcher ( Receiver [ pathlib . Path ]): \"\"\"A channel receiver that watches for file events.\"\"\" def __init__ ( self , paths : List [ Union [ pathlib . Path , str ]], event_types : Optional [ Set [ EventType ]] = None , ) -> None : \"\"\"Create a `FileWatcher` instance. Args: paths: Paths to watch for changes. event_types: Types of events to watch for or `None` to watch for all event types. \"\"\" if event_types is None : event_types = { EventType . CREATE , EventType . MODIFY , EventType . DELETE } self . event_types = event_types self . _stop_event = asyncio . Event () self . _paths = [ path if isinstance ( path , pathlib . Path ) else pathlib . Path ( path ) for path in paths ] self . _awatch = awatch ( * self . _paths , stop_event = self . _stop_event , watch_filter = lambda change , path_str : ( change in [ event_type . value for event_type in event_types ] # type: ignore and pathlib . Path ( path_str ) . is_file () ), ) def __del__ ( self ) -> None : \"\"\"Cleanup registered watches. `awatch` passes the `stop_event` to a separate task/thread. This way `awatch` getting destroyed properly. The background task will continue until the signal is received. \"\"\" self . _stop_event . set () async def receive ( self ) -> Optional [ pathlib . Path ]: \"\"\"Wait for the next file event and return its path. Returns: Path of next file. \"\"\" while True : changes = await self . _awatch . __anext__ () for change in changes : # Tuple of (Change, path) returned by watchfiles if change is None or len ( change ) != 2 : return None _ , path_str = change path = pathlib . Path ( path_str ) return path","title":"FileWatcher"},{"location":"reference/frequenz/channels/#frequenz.channels.FileWatcher-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/#frequenz.channels.utils.file_watcher.FileWatcher.__del__","text":"Cleanup registered watches. awatch passes the stop_event to a separate task/thread. This way awatch getting destroyed properly. The background task will continue until the signal is received. Source code in frequenz/channels/utils/file_watcher.py 56 57 58 59 60 61 62 63 def __del__ ( self ) -> None : \"\"\"Cleanup registered watches. `awatch` passes the `stop_event` to a separate task/thread. This way `awatch` getting destroyed properly. The background task will continue until the signal is received. \"\"\" self . _stop_event . set ()","title":"__del__()"},{"location":"reference/frequenz/channels/#frequenz.channels.utils.file_watcher.FileWatcher.__init__","text":"Create a FileWatcher instance. PARAMETER DESCRIPTION paths Paths to watch for changes. TYPE: List [ Union [ pathlib . Path , str ]] event_types Types of events to watch for or None to watch for all event types. TYPE: Optional [ Set [ EventType ]] DEFAULT: None Source code in frequenz/channels/utils/file_watcher.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def __init__ ( self , paths : List [ Union [ pathlib . Path , str ]], event_types : Optional [ Set [ EventType ]] = None , ) -> None : \"\"\"Create a `FileWatcher` instance. Args: paths: Paths to watch for changes. event_types: Types of events to watch for or `None` to watch for all event types. \"\"\" if event_types is None : event_types = { EventType . CREATE , EventType . MODIFY , EventType . DELETE } self . event_types = event_types self . _stop_event = asyncio . Event () self . _paths = [ path if isinstance ( path , pathlib . Path ) else pathlib . Path ( path ) for path in paths ] self . _awatch = awatch ( * self . _paths , stop_event = self . _stop_event , watch_filter = lambda change , path_str : ( change in [ event_type . value for event_type in event_types ] # type: ignore and pathlib . Path ( path_str ) . is_file () ), )","title":"__init__()"},{"location":"reference/frequenz/channels/#frequenz.channels.utils.file_watcher.FileWatcher.receive","text":"Wait for the next file event and return its path. RETURNS DESCRIPTION Optional [ pathlib . Path ] Path of next file. Source code in frequenz/channels/utils/file_watcher.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 async def receive ( self ) -> Optional [ pathlib . Path ]: \"\"\"Wait for the next file event and return its path. Returns: Path of next file. \"\"\" while True : changes = await self . _awatch . __anext__ () for change in changes : # Tuple of (Change, path) returned by watchfiles if change is None or len ( change ) != 2 : return None _ , path_str = change path = pathlib . Path ( path_str ) return path","title":"receive()"},{"location":"reference/frequenz/channels/#frequenz.channels.Merge","text":"Bases: Receiver [ T ] Merge messages coming from multiple channels into a single stream. Example For example, if there are two channel receivers with the same type, they can be awaited together, and their results merged into a single stream, by using Merge like this: merge = Merge ( receiver1 , receiver2 ) while msg := await merge . receive (): # do something with msg pass Source code in frequenz/channels/merge.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class Merge ( Receiver [ T ]): \"\"\"Merge messages coming from multiple channels into a single stream. Example: For example, if there are two channel receivers with the same type, they can be awaited together, and their results merged into a single stream, by using `Merge` like this: ```python merge = Merge(receiver1, receiver2) while msg := await merge.receive(): # do something with msg pass ``` \"\"\" def __init__ ( self , * args : Receiver [ T ]) -> None : \"\"\"Create a `Merge` instance. Args: *args: sequence of channel receivers. \"\"\" self . _receivers = { str ( id ): recv for id , recv in enumerate ( args )} self . _pending : Set [ asyncio . Task [ Any ]] = { asyncio . create_task ( recv . receive (), name = name ) for name , recv in self . _receivers . items () } self . _results : Deque [ T ] = deque ( maxlen = len ( self . _receivers )) def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel () async def receive ( self ) -> Optional [ T ]: \"\"\"Wait until there's a message in any of the channels. Returns: The next message that was received, or `None`, if all channels have closed. \"\"\" # we use a while loop to continue to wait for new data, in case the # previous `wait` completed because a channel was closed. while True : if len ( self . _results ) > 0 : return self . _results . popleft () if len ( self . _pending ) == 0 : return None done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () result = item . result () # if channel is closed, don't add a task for it again. if result is None : continue self . _results . append ( result ) self . _pending . add ( asyncio . create_task ( self . _receivers [ name ] . receive (), name = name ) )","title":"Merge"},{"location":"reference/frequenz/channels/#frequenz.channels.Merge-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/#frequenz.channels.merge.Merge.__del__","text":"Cleanup any pending tasks. Source code in frequenz/channels/merge.py 42 43 44 45 def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel ()","title":"__del__()"},{"location":"reference/frequenz/channels/#frequenz.channels.merge.Merge.__init__","text":"Create a Merge instance. PARAMETER DESCRIPTION *args sequence of channel receivers. TYPE: Receiver [ T ] DEFAULT: () Source code in frequenz/channels/merge.py 29 30 31 32 33 34 35 36 37 38 39 40 def __init__ ( self , * args : Receiver [ T ]) -> None : \"\"\"Create a `Merge` instance. Args: *args: sequence of channel receivers. \"\"\" self . _receivers = { str ( id ): recv for id , recv in enumerate ( args )} self . _pending : Set [ asyncio . Task [ Any ]] = { asyncio . create_task ( recv . receive (), name = name ) for name , recv in self . _receivers . items () } self . _results : Deque [ T ] = deque ( maxlen = len ( self . _receivers ))","title":"__init__()"},{"location":"reference/frequenz/channels/#frequenz.channels.merge.Merge.receive","text":"Wait until there's a message in any of the channels. RETURNS DESCRIPTION Optional [ T ] The next message that was received, or None , if all channels have closed. Source code in frequenz/channels/merge.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 async def receive ( self ) -> Optional [ T ]: \"\"\"Wait until there's a message in any of the channels. Returns: The next message that was received, or `None`, if all channels have closed. \"\"\" # we use a while loop to continue to wait for new data, in case the # previous `wait` completed because a channel was closed. while True : if len ( self . _results ) > 0 : return self . _results . popleft () if len ( self . _pending ) == 0 : return None done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () result = item . result () # if channel is closed, don't add a task for it again. if result is None : continue self . _results . append ( result ) self . _pending . add ( asyncio . create_task ( self . _receivers [ name ] . receive (), name = name ) )","title":"receive()"},{"location":"reference/frequenz/channels/#frequenz.channels.MergeNamed","text":"Bases: Receiver [ Tuple [ str , T ]] Merge messages coming from multiple named channels into a single stream. Source code in frequenz/channels/merge_named.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class MergeNamed ( Receiver [ Tuple [ str , T ]]): \"\"\"Merge messages coming from multiple named channels into a single stream.\"\"\" def __init__ ( self , ** kwargs : Receiver [ T ]) -> None : \"\"\"Create a `MergeNamed` instance. Args: **kwargs: sequence of channel receivers. \"\"\" self . _receivers = kwargs self . _pending : Set [ asyncio . Task [ Any ]] = { asyncio . create_task ( recv . receive (), name = name ) for name , recv in self . _receivers . items () } self . _results : Deque [ Tuple [ str , T ]] = deque ( maxlen = len ( self . _receivers )) def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel () async def receive ( self ) -> Optional [ Tuple [ str , T ]]: \"\"\"Wait until there's a message in any of the channels. Returns: The next message that was received, or `None`, if all channels have closed. \"\"\" # we use a while loop to continue to wait for new data, in case the # previous `wait` completed because a channel was closed. while True : if len ( self . _results ) > 0 : return self . _results . popleft () if len ( self . _pending ) == 0 : return None done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () result = item . result () # if channel is closed, don't add a task for it again. if result is None : continue self . _results . append (( name , result )) self . _pending . add ( asyncio . create_task ( self . _receivers [ name ] . receive (), name = name ) )","title":"MergeNamed"},{"location":"reference/frequenz/channels/#frequenz.channels.MergeNamed-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/#frequenz.channels.merge_named.MergeNamed.__del__","text":"Cleanup any pending tasks. Source code in frequenz/channels/merge_named.py 29 30 31 32 def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel ()","title":"__del__()"},{"location":"reference/frequenz/channels/#frequenz.channels.merge_named.MergeNamed.__init__","text":"Create a MergeNamed instance. PARAMETER DESCRIPTION **kwargs sequence of channel receivers. TYPE: Receiver [ T ] DEFAULT: {} Source code in frequenz/channels/merge_named.py 16 17 18 19 20 21 22 23 24 25 26 27 def __init__ ( self , ** kwargs : Receiver [ T ]) -> None : \"\"\"Create a `MergeNamed` instance. Args: **kwargs: sequence of channel receivers. \"\"\" self . _receivers = kwargs self . _pending : Set [ asyncio . Task [ Any ]] = { asyncio . create_task ( recv . receive (), name = name ) for name , recv in self . _receivers . items () } self . _results : Deque [ Tuple [ str , T ]] = deque ( maxlen = len ( self . _receivers ))","title":"__init__()"},{"location":"reference/frequenz/channels/#frequenz.channels.merge_named.MergeNamed.receive","text":"Wait until there's a message in any of the channels. RETURNS DESCRIPTION Optional [ Tuple [ str , T ]] The next message that was received, or None , if all channels have closed. Source code in frequenz/channels/merge_named.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 async def receive ( self ) -> Optional [ Tuple [ str , T ]]: \"\"\"Wait until there's a message in any of the channels. Returns: The next message that was received, or `None`, if all channels have closed. \"\"\" # we use a while loop to continue to wait for new data, in case the # previous `wait` completed because a channel was closed. while True : if len ( self . _results ) > 0 : return self . _results . popleft () if len ( self . _pending ) == 0 : return None done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () result = item . result () # if channel is closed, don't add a task for it again. if result is None : continue self . _results . append (( name , result )) self . _pending . add ( asyncio . create_task ( self . _receivers [ name ] . receive (), name = name ) )","title":"receive()"},{"location":"reference/frequenz/channels/#frequenz.channels.Peekable","text":"Bases: ABC , Generic [ T ] A channel peekable. A Peekable provides a peek() method that allows the user to get a peek at the latest value in the channel, without consuming anything. Source code in frequenz/channels/base_classes.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 class Peekable ( ABC , Generic [ T ]): \"\"\"A channel peekable. A Peekable provides a [peek()][frequenz.channels.Peekable] method that allows the user to get a peek at the latest value in the channel, without consuming anything. \"\"\" @abstractmethod def peek ( self ) -> Optional [ T ]: \"\"\"Return the latest value that was sent to the channel. Returns: The latest value received by the channel, and `None`, if nothing has been sent to the channel yet. \"\"\"","title":"Peekable"},{"location":"reference/frequenz/channels/#frequenz.channels.Peekable-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/#frequenz.channels.base_classes.Peekable.peek","text":"Return the latest value that was sent to the channel. RETURNS DESCRIPTION Optional [ T ] The latest value received by the channel, and None , if nothing has been sent to the channel yet. Source code in frequenz/channels/base_classes.py 97 98 99 100 101 102 103 104 @abstractmethod def peek ( self ) -> Optional [ T ]: \"\"\"Return the latest value that was sent to the channel. Returns: The latest value received by the channel, and `None`, if nothing has been sent to the channel yet. \"\"\"","title":"peek()"},{"location":"reference/frequenz/channels/#frequenz.channels.Receiver","text":"Bases: ABC , Generic [ T ] A channel Receiver. Source code in frequenz/channels/base_classes.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class Receiver ( ABC , Generic [ T ]): \"\"\"A channel Receiver.\"\"\" @abstractmethod async def receive ( self ) -> Optional [ T ]: \"\"\"Receive a message from the channel. Returns: `None`, if the channel is closed, a message otherwise. \"\"\" def __aiter__ ( self ) -> Receiver [ T ]: \"\"\"Initialize the async iterator over received values. Returns: `self`, since no extra setup is needed for the iterator. \"\"\" return self async def __anext__ ( self ) -> T : \"\"\"Await the next value in the async iteration over received values. Returns: The next value received. Raises: StopAsyncIteration: if we receive `None`, i.e. if the underlying channel is closed. \"\"\" received = await self . receive () if received is None : raise StopAsyncIteration return received def map ( self , call : Callable [[ T ], U ]) -> Receiver [ U ]: \"\"\"Return a receiver with `call` applied on incoming messages. Args: call: function to apply on incoming messages. Returns: A `Receiver` to read results of the given function from. \"\"\" return _Map ( self , call ) def into_peekable ( self ) -> Peekable [ T ]: \"\"\"Convert the `Receiver` implementation into a `Peekable`. Once this function has been called, the receiver will no longer be usable, and calling `receive` on the receiver will raise an exception. Raises: NotImplementedError: when a `Receiver` implementation doesn't have a custom `get_peekable` implementation. \"\"\" raise NotImplementedError ( \"This receiver does not implement `into_peekable`\" )","title":"Receiver"},{"location":"reference/frequenz/channels/#frequenz.channels.Receiver-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/#frequenz.channels.base_classes.Receiver.__aiter__","text":"Initialize the async iterator over received values. RETURNS DESCRIPTION Receiver [ T ] self , since no extra setup is needed for the iterator. Source code in frequenz/channels/base_classes.py 42 43 44 45 46 47 48 def __aiter__ ( self ) -> Receiver [ T ]: \"\"\"Initialize the async iterator over received values. Returns: `self`, since no extra setup is needed for the iterator. \"\"\" return self","title":"__aiter__()"},{"location":"reference/frequenz/channels/#frequenz.channels.base_classes.Receiver.__anext__","text":"Await the next value in the async iteration over received values. RETURNS DESCRIPTION T The next value received. RAISES DESCRIPTION StopAsyncIteration if we receive None , i.e. if the underlying channel is closed. Source code in frequenz/channels/base_classes.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 async def __anext__ ( self ) -> T : \"\"\"Await the next value in the async iteration over received values. Returns: The next value received. Raises: StopAsyncIteration: if we receive `None`, i.e. if the underlying channel is closed. \"\"\" received = await self . receive () if received is None : raise StopAsyncIteration return received","title":"__anext__()"},{"location":"reference/frequenz/channels/#frequenz.channels.base_classes.Receiver.into_peekable","text":"Convert the Receiver implementation into a Peekable . Once this function has been called, the receiver will no longer be usable, and calling receive on the receiver will raise an exception. RAISES DESCRIPTION NotImplementedError when a Receiver implementation doesn't have a custom get_peekable implementation. Source code in frequenz/channels/base_classes.py 76 77 78 79 80 81 82 83 84 85 86 def into_peekable ( self ) -> Peekable [ T ]: \"\"\"Convert the `Receiver` implementation into a `Peekable`. Once this function has been called, the receiver will no longer be usable, and calling `receive` on the receiver will raise an exception. Raises: NotImplementedError: when a `Receiver` implementation doesn't have a custom `get_peekable` implementation. \"\"\" raise NotImplementedError ( \"This receiver does not implement `into_peekable`\" )","title":"into_peekable()"},{"location":"reference/frequenz/channels/#frequenz.channels.base_classes.Receiver.map","text":"Return a receiver with call applied on incoming messages. PARAMETER DESCRIPTION call function to apply on incoming messages. TYPE: Callable [[ T ], U ] RETURNS DESCRIPTION Receiver [ U ] A Receiver to read results of the given function from. Source code in frequenz/channels/base_classes.py 65 66 67 68 69 70 71 72 73 74 def map ( self , call : Callable [[ T ], U ]) -> Receiver [ U ]: \"\"\"Return a receiver with `call` applied on incoming messages. Args: call: function to apply on incoming messages. Returns: A `Receiver` to read results of the given function from. \"\"\" return _Map ( self , call )","title":"map()"},{"location":"reference/frequenz/channels/#frequenz.channels.base_classes.Receiver.receive","text":"Receive a message from the channel. RETURNS DESCRIPTION Optional [ T ] None , if the channel is closed, a message otherwise. Source code in frequenz/channels/base_classes.py 34 35 36 37 38 39 40 @abstractmethod async def receive ( self ) -> Optional [ T ]: \"\"\"Receive a message from the channel. Returns: `None`, if the channel is closed, a message otherwise. \"\"\"","title":"receive()"},{"location":"reference/frequenz/channels/#frequenz.channels.Select","text":"Select the next available message from a group of AsyncIterators. If Select was created with more AsyncIterator than what are read in the if-chain after each call to ready() , messages coming in the additional async iterators are dropped, and a warning message is logged. Receiver s also function as AsyncIterator . Example For example, if there are two async iterators that you want to simultaneously wait on, this can be done with: select = Select ( name1 = receiver1 , name2 = receiver2 ) while await select . ready (): if msg := select . name1 : if val := msg . inner : # do something with `val` pass else : # handle closure of receiver. pass elif msg := select . name2 : # do something with `msg.inner` pass Source code in frequenz/channels/select.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class Select : \"\"\"Select the next available message from a group of AsyncIterators. If `Select` was created with more `AsyncIterator` than what are read in the if-chain after each call to [ready()][frequenz.channels.Select.ready], messages coming in the additional async iterators are dropped, and a warning message is logged. [Receiver][frequenz.channels.Receiver]s also function as `AsyncIterator`. Example: For example, if there are two async iterators that you want to simultaneously wait on, this can be done with: ```python select = Select(name1 = receiver1, name2 = receiver2) while await select.ready(): if msg := select.name1: if val := msg.inner: # do something with `val` pass else: # handle closure of receiver. pass elif msg := select.name2: # do something with `msg.inner` pass ``` \"\"\" def __init__ ( self , ** kwargs : AsyncIterator [ Any ]) -> None : \"\"\"Create a `Select` instance. Args: **kwargs: sequence of async iterators \"\"\" self . _receivers = kwargs self . _pending : Set [ asyncio . Task [ Any ]] = set () for name , recv in self . _receivers . items (): # can replace __anext__() to anext() (Only Python 3.10>=) msg = recv . __anext__ () # pylint: disable=unnecessary-dunder-call self . _pending . add ( asyncio . create_task ( msg , name = name )) # type: ignore self . _ready_count = 0 self . _prev_ready_count = 0 self . _result : Dict [ str , Optional [ _Selected ]] = { name : None for name in self . _receivers } def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel () async def ready ( self ) -> bool : \"\"\"Wait until there is a message in any of the async iterators. Returns `True` if there is a message available, and `False` if all async iterators have closed. Returns: Whether there are further messages or not. \"\"\" if self . _ready_count > 0 : if self . _ready_count == self . _prev_ready_count : dropped_names : List [ str ] = [] for name , value in self . _result . items (): if value is not None : dropped_names . append ( name ) self . _result [ name ] = None self . _ready_count = 0 self . _prev_ready_count = 0 logger . warning ( \"Select.ready() dropped data from async iterator(s): %s , \" \"because no messages have been fetched since the last call to ready().\" , dropped_names , ) else : self . _prev_ready_count = self . _ready_count return True if len ( self . _pending ) == 0 : return False # once all the pending messages have been consumed, reset the # `_prev_ready_count` as well, and wait for new messages. self . _prev_ready_count = 0 done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () if isinstance ( item . exception (), StopAsyncIteration ): result = None else : result = item . result () self . _ready_count += 1 self . _result [ name ] = _Selected ( result ) # if channel or AsyncIterator is closed # don't add a task for it again. if result is None : continue msg = self . _receivers [ # pylint: disable=unnecessary-dunder-call name ] . __anext__ () self . _pending . add ( asyncio . create_task ( msg , name = name )) # type: ignore return True def __getattr__ ( self , name : str ) -> Optional [ Any ]: \"\"\"Return the latest unread message from a `AsyncIterator`, if available. Args: name: Name of the channel. Returns: Latest unread message for the specified `AsyncIterator`, or `None`. Raises: KeyError: when the name was not specified when creating the `Select` instance. \"\"\" result = self . _result [ name ] if result is None : return result self . _result [ name ] = None self . _ready_count -= 1 return result","title":"Select"},{"location":"reference/frequenz/channels/#frequenz.channels.Select-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/#frequenz.channels.select.Select.__del__","text":"Cleanup any pending tasks. Source code in frequenz/channels/select.py 81 82 83 84 def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel ()","title":"__del__()"},{"location":"reference/frequenz/channels/#frequenz.channels.select.Select.__getattr__","text":"Return the latest unread message from a AsyncIterator , if available. PARAMETER DESCRIPTION name Name of the channel. TYPE: str RETURNS DESCRIPTION Optional [ Any ] Latest unread message for the specified AsyncIterator , or None . RAISES DESCRIPTION KeyError when the name was not specified when creating the Select instance. Source code in frequenz/channels/select.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def __getattr__ ( self , name : str ) -> Optional [ Any ]: \"\"\"Return the latest unread message from a `AsyncIterator`, if available. Args: name: Name of the channel. Returns: Latest unread message for the specified `AsyncIterator`, or `None`. Raises: KeyError: when the name was not specified when creating the `Select` instance. \"\"\" result = self . _result [ name ] if result is None : return result self . _result [ name ] = None self . _ready_count -= 1 return result","title":"__getattr__()"},{"location":"reference/frequenz/channels/#frequenz.channels.select.Select.__init__","text":"Create a Select instance. PARAMETER DESCRIPTION **kwargs sequence of async iterators TYPE: AsyncIterator [ Any ] DEFAULT: {} Source code in frequenz/channels/select.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def __init__ ( self , ** kwargs : AsyncIterator [ Any ]) -> None : \"\"\"Create a `Select` instance. Args: **kwargs: sequence of async iterators \"\"\" self . _receivers = kwargs self . _pending : Set [ asyncio . Task [ Any ]] = set () for name , recv in self . _receivers . items (): # can replace __anext__() to anext() (Only Python 3.10>=) msg = recv . __anext__ () # pylint: disable=unnecessary-dunder-call self . _pending . add ( asyncio . create_task ( msg , name = name )) # type: ignore self . _ready_count = 0 self . _prev_ready_count = 0 self . _result : Dict [ str , Optional [ _Selected ]] = { name : None for name in self . _receivers }","title":"__init__()"},{"location":"reference/frequenz/channels/#frequenz.channels.select.Select.ready","text":"Wait until there is a message in any of the async iterators. Returns True if there is a message available, and False if all async iterators have closed. RETURNS DESCRIPTION bool Whether there are further messages or not. Source code in frequenz/channels/select.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 async def ready ( self ) -> bool : \"\"\"Wait until there is a message in any of the async iterators. Returns `True` if there is a message available, and `False` if all async iterators have closed. Returns: Whether there are further messages or not. \"\"\" if self . _ready_count > 0 : if self . _ready_count == self . _prev_ready_count : dropped_names : List [ str ] = [] for name , value in self . _result . items (): if value is not None : dropped_names . append ( name ) self . _result [ name ] = None self . _ready_count = 0 self . _prev_ready_count = 0 logger . warning ( \"Select.ready() dropped data from async iterator(s): %s , \" \"because no messages have been fetched since the last call to ready().\" , dropped_names , ) else : self . _prev_ready_count = self . _ready_count return True if len ( self . _pending ) == 0 : return False # once all the pending messages have been consumed, reset the # `_prev_ready_count` as well, and wait for new messages. self . _prev_ready_count = 0 done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () if isinstance ( item . exception (), StopAsyncIteration ): result = None else : result = item . result () self . _ready_count += 1 self . _result [ name ] = _Selected ( result ) # if channel or AsyncIterator is closed # don't add a task for it again. if result is None : continue msg = self . _receivers [ # pylint: disable=unnecessary-dunder-call name ] . __anext__ () self . _pending . add ( asyncio . create_task ( msg , name = name )) # type: ignore return True","title":"ready()"},{"location":"reference/frequenz/channels/#frequenz.channels.Sender","text":"Bases: ABC , Generic [ T ] A channel Sender. Source code in frequenz/channels/base_classes.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Sender ( ABC , Generic [ T ]): \"\"\"A channel Sender.\"\"\" @abstractmethod async def send ( self , msg : T ) -> bool : \"\"\"Send a message to the channel. Args: msg: The message to be sent. Returns: Whether the message was sent, based on whether the channel is open or not. \"\"\"","title":"Sender"},{"location":"reference/frequenz/channels/#frequenz.channels.Sender-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/#frequenz.channels.base_classes.Sender.send","text":"Send a message to the channel. PARAMETER DESCRIPTION msg The message to be sent. TYPE: T RETURNS DESCRIPTION bool Whether the message was sent, based on whether the channel is open or not. Source code in frequenz/channels/base_classes.py 18 19 20 21 22 23 24 25 26 27 28 @abstractmethod async def send ( self , msg : T ) -> bool : \"\"\"Send a message to the channel. Args: msg: The message to be sent. Returns: Whether the message was sent, based on whether the channel is open or not. \"\"\"","title":"send()"},{"location":"reference/frequenz/channels/#frequenz.channels.Timer","text":"Bases: Receiver [ datetime ] A timer receiver that returns the timestamp every interval seconds. Primarily for use with Select . Example When you want something to happen with a fixed period: timer = channel . Timer ( 30.0 ) select = Select ( bat_1 = receiver1 , timer = timer ) while await select . ready (): if msg := select . bat_1 : if val := msg . inner : process_data ( val ) else : logging . warn ( \"battery channel closed\" ) if ts := select . timer : # something to do once every 30 seconds pass When you want something to happen when nothing else has happened in a certain interval: timer = channel . Timer ( 30.0 ) select = Select ( bat_1 = receiver1 , timer = timer ) while await select . ready (): timer . reset () if msg := select . bat_1 : if val := msg . inner : process_data ( val ) else : logging . warn ( \"battery channel closed\" ) if ts := select . timer : # something to do if there's no battery data for 30 seconds pass Source code in frequenz/channels/utils/timer.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class Timer ( Receiver [ datetime ]): \"\"\"A timer receiver that returns the timestamp every `interval` seconds. Primarily for use with [Select][frequenz.channels.Select]. Example: When you want something to happen with a fixed period: ```python timer = channel.Timer(30.0) select = Select(bat_1 = receiver1, timer = timer) while await select.ready(): if msg := select.bat_1: if val := msg.inner: process_data(val) else: logging.warn(\"battery channel closed\") if ts := select.timer: # something to do once every 30 seconds pass ``` When you want something to happen when nothing else has happened in a certain interval: ```python timer = channel.Timer(30.0) select = Select(bat_1 = receiver1, timer = timer) while await select.ready(): timer.reset() if msg := select.bat_1: if val := msg.inner: process_data(val) else: logging.warn(\"battery channel closed\") if ts := select.timer: # something to do if there's no battery data for 30 seconds pass ``` \"\"\" def __init__ ( self , interval : float ) -> None : \"\"\"Create a `Timer` instance. Args: interval: number of seconds between messages. \"\"\" self . _stopped = False self . _interval = timedelta ( seconds = interval ) self . _next_msg_time = datetime . now () + self . _interval def reset ( self ) -> None : \"\"\"Reset the timer to start timing from `now`.\"\"\" self . _next_msg_time = datetime . now () + self . _interval def stop ( self ) -> None : \"\"\"Stop the timer. Once `stop` has been called, all subsequent calls to [receive()][frequenz.channels.Timer.receive] will immediately return `None`. \"\"\" self . _stopped = True async def receive ( self ) -> Optional [ datetime ]: \"\"\"Return the current time once the next tick is due. Returns: The time of the next tick or `None` if [stop()][frequenz.channels.Timer.stop] has been called on the timer. \"\"\" if self . _stopped : return None now = datetime . now () diff = self . _next_msg_time - now while diff . total_seconds () > 0 : await asyncio . sleep ( diff . total_seconds ()) now = datetime . now () diff = self . _next_msg_time - now self . _next_msg_time = now + self . _interval return now","title":"Timer"},{"location":"reference/frequenz/channels/#frequenz.channels.Timer-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/#frequenz.channels.utils.timer.Timer.__init__","text":"Create a Timer instance. PARAMETER DESCRIPTION interval number of seconds between messages. TYPE: float Source code in frequenz/channels/utils/timer.py 54 55 56 57 58 59 60 61 62 def __init__ ( self , interval : float ) -> None : \"\"\"Create a `Timer` instance. Args: interval: number of seconds between messages. \"\"\" self . _stopped = False self . _interval = timedelta ( seconds = interval ) self . _next_msg_time = datetime . now () + self . _interval","title":"__init__()"},{"location":"reference/frequenz/channels/#frequenz.channels.utils.timer.Timer.receive","text":"Return the current time once the next tick is due. RETURNS DESCRIPTION Optional [ datetime ] The time of the next tick or None if stop() has been called on the timer. Source code in frequenz/channels/utils/timer.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 async def receive ( self ) -> Optional [ datetime ]: \"\"\"Return the current time once the next tick is due. Returns: The time of the next tick or `None` if [stop()][frequenz.channels.Timer.stop] has been called on the timer. \"\"\" if self . _stopped : return None now = datetime . now () diff = self . _next_msg_time - now while diff . total_seconds () > 0 : await asyncio . sleep ( diff . total_seconds ()) now = datetime . now () diff = self . _next_msg_time - now self . _next_msg_time = now + self . _interval return now","title":"receive()"},{"location":"reference/frequenz/channels/#frequenz.channels.utils.timer.Timer.reset","text":"Reset the timer to start timing from now . Source code in frequenz/channels/utils/timer.py 64 65 66 def reset ( self ) -> None : \"\"\"Reset the timer to start timing from `now`.\"\"\" self . _next_msg_time = datetime . now () + self . _interval","title":"reset()"},{"location":"reference/frequenz/channels/#frequenz.channels.utils.timer.Timer.stop","text":"Stop the timer. Once stop has been called, all subsequent calls to receive() will immediately return None . Source code in frequenz/channels/utils/timer.py 68 69 70 71 72 73 74 75 def stop ( self ) -> None : \"\"\"Stop the timer. Once `stop` has been called, all subsequent calls to [receive()][frequenz.channels.Timer.receive] will immediately return `None`. \"\"\" self . _stopped = True","title":"stop()"},{"location":"reference/frequenz/channels/anycast/","text":"frequenz.channels.anycast \u00a4 A channel for sending data across async tasks. Classes \u00a4 frequenz.channels.anycast.Anycast \u00a4 Bases: Generic [ T ] A channel for sending data across async tasks. Anycast channels support multiple senders and multiple receivers. A message sent through a sender will be received by exactly one receiver. In cases where each message need to be received by every receiver, a Broadcast channel may be used. Uses an deque internally, so Anycast channels are not thread-safe. When there are multiple channel receivers, they can be awaited simultaneously using Select , Merge or MergeNamed . Example async def send ( sender : channel . Sender ) -> None : while True : next = random . randint ( 3 , 17 ) print ( f \"sending: { next } \" ) await sender . send ( next ) async def recv ( id : int , receiver : channel . Receiver ) -> None : while True : next = await receiver . receive () print ( f \"receiver_ { id } received { next } \" ) await asyncio . sleep ( 0.1 ) # sleep (or work) with the data acast = channel . Anycast () sender = acast . get_sender () receiver_1 = acast . get_receiver () asyncio . create_task ( send ( sender )) await recv ( 1 , receiver_1 ) Check the tests and benchmarks directories for more examples. Source code in frequenz/channels/anycast.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 class Anycast ( Generic [ T ]): \"\"\"A channel for sending data across async tasks. Anycast channels support multiple senders and multiple receivers. A message sent through a sender will be received by exactly one receiver. In cases where each message need to be received by every receiver, a [Broadcast][frequenz.channels.Broadcast] channel may be used. Uses an [deque][collections.deque] internally, so Anycast channels are not thread-safe. When there are multiple channel receivers, they can be awaited simultaneously using [Select][frequenz.channels.Select], [Merge][frequenz.channels.Merge] or [MergeNamed][frequenz.channels.MergeNamed]. Example: ``` python async def send(sender: channel.Sender) -> None: while True: next = random.randint(3, 17) print(f\"sending: {next}\") await sender.send(next) async def recv(id: int, receiver: channel.Receiver) -> None: while True: next = await receiver.receive() print(f\"receiver_{id} received {next}\") await asyncio.sleep(0.1) # sleep (or work) with the data acast = channel.Anycast() sender = acast.get_sender() receiver_1 = acast.get_receiver() asyncio.create_task(send(sender)) await recv(1, receiver_1) ``` Check the `tests` and `benchmarks` directories for more examples. \"\"\" def __init__ ( self , maxsize : int = 10 ) -> None : \"\"\"Create an Anycast channel. Args: maxsize: Size of the channel's buffer. \"\"\" self . limit : int = maxsize self . deque : Deque [ T ] = deque ( maxlen = maxsize ) self . send_cv : Condition = Condition () self . recv_cv : Condition = Condition () self . closed : bool = False async def close ( self ) -> None : \"\"\"Close the channel. Any further attempts to [send()][frequenz.channels.Sender.send] data will return `False`. Receivers will still be able to drain the pending items on the channel, but after that, subsequent [receive()][frequenz.channels.Receiver.receive] calls will return `None` immediately. \"\"\" self . closed = True async with self . send_cv : self . send_cv . notify_all () async with self . recv_cv : self . recv_cv . notify_all () def get_sender ( self ) -> Sender [ T ]: \"\"\"Create a new sender. Returns: A Sender instance attached to the Anycast channel. \"\"\" return Sender ( self ) def get_receiver ( self ) -> Receiver [ T ]: \"\"\"Create a new receiver. Returns: A Receiver instance attached to the Anycast channel. \"\"\" return Receiver ( self ) Functions \u00a4 __init__ ( maxsize = 10 ) \u00a4 Create an Anycast channel. PARAMETER DESCRIPTION maxsize Size of the channel's buffer. TYPE: int DEFAULT: 10 Source code in frequenz/channels/anycast.py 63 64 65 66 67 68 69 70 71 72 73 def __init__ ( self , maxsize : int = 10 ) -> None : \"\"\"Create an Anycast channel. Args: maxsize: Size of the channel's buffer. \"\"\" self . limit : int = maxsize self . deque : Deque [ T ] = deque ( maxlen = maxsize ) self . send_cv : Condition = Condition () self . recv_cv : Condition = Condition () self . closed : bool = False close () async \u00a4 Close the channel. Any further attempts to send() data will return False . Receivers will still be able to drain the pending items on the channel, but after that, subsequent receive() calls will return None immediately. Source code in frequenz/channels/anycast.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 async def close ( self ) -> None : \"\"\"Close the channel. Any further attempts to [send()][frequenz.channels.Sender.send] data will return `False`. Receivers will still be able to drain the pending items on the channel, but after that, subsequent [receive()][frequenz.channels.Receiver.receive] calls will return `None` immediately. \"\"\" self . closed = True async with self . send_cv : self . send_cv . notify_all () async with self . recv_cv : self . recv_cv . notify_all () get_receiver () \u00a4 Create a new receiver. RETURNS DESCRIPTION Receiver [ T ] A Receiver instance attached to the Anycast channel. Source code in frequenz/channels/anycast.py 101 102 103 104 105 106 107 def get_receiver ( self ) -> Receiver [ T ]: \"\"\"Create a new receiver. Returns: A Receiver instance attached to the Anycast channel. \"\"\" return Receiver ( self ) get_sender () \u00a4 Create a new sender. RETURNS DESCRIPTION Sender [ T ] A Sender instance attached to the Anycast channel. Source code in frequenz/channels/anycast.py 93 94 95 96 97 98 99 def get_sender ( self ) -> Sender [ T ]: \"\"\"Create a new sender. Returns: A Sender instance attached to the Anycast channel. \"\"\" return Sender ( self ) frequenz.channels.anycast.Receiver \u00a4 Bases: BaseReceiver [ T ] A receiver to receive messages from an Anycast channel. Should not be created directly, but through the Anycast.get_receiver() method. Source code in frequenz/channels/anycast.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 class Receiver ( BaseReceiver [ T ]): \"\"\"A receiver to receive messages from an Anycast channel. Should not be created directly, but through the `Anycast.get_receiver()` method. \"\"\" def __init__ ( self , chan : Anycast [ T ]) -> None : \"\"\"Create a channel receiver. Args: chan: A reference to the channel that this receiver belongs to. \"\"\" self . _chan = chan async def receive ( self ) -> Optional [ T ]: \"\"\"Receive a message from the channel. Waits for an message to become available, and returns that message. When there are multiple receivers for the channel, only one receiver will receive each message. Returns: `None`, if the channel is closed, a message otherwise. \"\"\" while len ( self . _chan . deque ) == 0 : if self . _chan . closed : return None async with self . _chan . recv_cv : await self . _chan . recv_cv . wait () ret = self . _chan . deque . popleft () async with self . _chan . send_cv : self . _chan . send_cv . notify ( 1 ) return ret Functions \u00a4 __init__ ( chan ) \u00a4 Create a channel receiver. PARAMETER DESCRIPTION chan A reference to the channel that this receiver belongs to. TYPE: Anycast [ T ] Source code in frequenz/channels/anycast.py 158 159 160 161 162 163 164 def __init__ ( self , chan : Anycast [ T ]) -> None : \"\"\"Create a channel receiver. Args: chan: A reference to the channel that this receiver belongs to. \"\"\" self . _chan = chan receive () async \u00a4 Receive a message from the channel. Waits for an message to become available, and returns that message. When there are multiple receivers for the channel, only one receiver will receive each message. RETURNS DESCRIPTION Optional [ T ] None , if the channel is closed, a message otherwise. Source code in frequenz/channels/anycast.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 async def receive ( self ) -> Optional [ T ]: \"\"\"Receive a message from the channel. Waits for an message to become available, and returns that message. When there are multiple receivers for the channel, only one receiver will receive each message. Returns: `None`, if the channel is closed, a message otherwise. \"\"\" while len ( self . _chan . deque ) == 0 : if self . _chan . closed : return None async with self . _chan . recv_cv : await self . _chan . recv_cv . wait () ret = self . _chan . deque . popleft () async with self . _chan . send_cv : self . _chan . send_cv . notify ( 1 ) return ret frequenz.channels.anycast.Sender \u00a4 Bases: BaseSender [ T ] A sender to send messages to an Anycast channel. Should not be created directly, but through the Anycast.get_sender() method. Source code in frequenz/channels/anycast.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 class Sender ( BaseSender [ T ]): \"\"\"A sender to send messages to an Anycast channel. Should not be created directly, but through the `Anycast.get_sender()` method. \"\"\" def __init__ ( self , chan : Anycast [ T ]) -> None : \"\"\"Create a channel sender. Args: chan: A reference to the channel that this sender belongs to. \"\"\" self . _chan = chan async def send ( self , msg : T ) -> bool : \"\"\"Send a message across the channel. To send, this method inserts the message into the Anycast channel's buffer. If the channel's buffer is full, waits for messages to get consumed, until there's some free space available in the buffer. Each message will be received by exactly one receiver. Args: msg: The message to be sent. Returns: Whether the message was sent, based on whether the channel is open or not. \"\"\" if self . _chan . closed : return False while len ( self . _chan . deque ) == self . _chan . deque . maxlen : async with self . _chan . send_cv : await self . _chan . send_cv . wait () self . _chan . deque . append ( msg ) async with self . _chan . recv_cv : self . _chan . recv_cv . notify ( 1 ) return True Functions \u00a4 __init__ ( chan ) \u00a4 Create a channel sender. PARAMETER DESCRIPTION chan A reference to the channel that this sender belongs to. TYPE: Anycast [ T ] Source code in frequenz/channels/anycast.py 117 118 119 120 121 122 123 def __init__ ( self , chan : Anycast [ T ]) -> None : \"\"\"Create a channel sender. Args: chan: A reference to the channel that this sender belongs to. \"\"\" self . _chan = chan send ( msg ) async \u00a4 Send a message across the channel. To send, this method inserts the message into the Anycast channel's buffer. If the channel's buffer is full, waits for messages to get consumed, until there's some free space available in the buffer. Each message will be received by exactly one receiver. PARAMETER DESCRIPTION msg The message to be sent. TYPE: T RETURNS DESCRIPTION bool Whether the message was sent, based on whether the channel is open or not. Source code in frequenz/channels/anycast.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 async def send ( self , msg : T ) -> bool : \"\"\"Send a message across the channel. To send, this method inserts the message into the Anycast channel's buffer. If the channel's buffer is full, waits for messages to get consumed, until there's some free space available in the buffer. Each message will be received by exactly one receiver. Args: msg: The message to be sent. Returns: Whether the message was sent, based on whether the channel is open or not. \"\"\" if self . _chan . closed : return False while len ( self . _chan . deque ) == self . _chan . deque . maxlen : async with self . _chan . send_cv : await self . _chan . send_cv . wait () self . _chan . deque . append ( msg ) async with self . _chan . recv_cv : self . _chan . recv_cv . notify ( 1 ) return True","title":"anycast"},{"location":"reference/frequenz/channels/anycast/#frequenz.channels.anycast","text":"A channel for sending data across async tasks.","title":"anycast"},{"location":"reference/frequenz/channels/anycast/#frequenz.channels.anycast-classes","text":"","title":"Classes"},{"location":"reference/frequenz/channels/anycast/#frequenz.channels.anycast.Anycast","text":"Bases: Generic [ T ] A channel for sending data across async tasks. Anycast channels support multiple senders and multiple receivers. A message sent through a sender will be received by exactly one receiver. In cases where each message need to be received by every receiver, a Broadcast channel may be used. Uses an deque internally, so Anycast channels are not thread-safe. When there are multiple channel receivers, they can be awaited simultaneously using Select , Merge or MergeNamed . Example async def send ( sender : channel . Sender ) -> None : while True : next = random . randint ( 3 , 17 ) print ( f \"sending: { next } \" ) await sender . send ( next ) async def recv ( id : int , receiver : channel . Receiver ) -> None : while True : next = await receiver . receive () print ( f \"receiver_ { id } received { next } \" ) await asyncio . sleep ( 0.1 ) # sleep (or work) with the data acast = channel . Anycast () sender = acast . get_sender () receiver_1 = acast . get_receiver () asyncio . create_task ( send ( sender )) await recv ( 1 , receiver_1 ) Check the tests and benchmarks directories for more examples. Source code in frequenz/channels/anycast.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 class Anycast ( Generic [ T ]): \"\"\"A channel for sending data across async tasks. Anycast channels support multiple senders and multiple receivers. A message sent through a sender will be received by exactly one receiver. In cases where each message need to be received by every receiver, a [Broadcast][frequenz.channels.Broadcast] channel may be used. Uses an [deque][collections.deque] internally, so Anycast channels are not thread-safe. When there are multiple channel receivers, they can be awaited simultaneously using [Select][frequenz.channels.Select], [Merge][frequenz.channels.Merge] or [MergeNamed][frequenz.channels.MergeNamed]. Example: ``` python async def send(sender: channel.Sender) -> None: while True: next = random.randint(3, 17) print(f\"sending: {next}\") await sender.send(next) async def recv(id: int, receiver: channel.Receiver) -> None: while True: next = await receiver.receive() print(f\"receiver_{id} received {next}\") await asyncio.sleep(0.1) # sleep (or work) with the data acast = channel.Anycast() sender = acast.get_sender() receiver_1 = acast.get_receiver() asyncio.create_task(send(sender)) await recv(1, receiver_1) ``` Check the `tests` and `benchmarks` directories for more examples. \"\"\" def __init__ ( self , maxsize : int = 10 ) -> None : \"\"\"Create an Anycast channel. Args: maxsize: Size of the channel's buffer. \"\"\" self . limit : int = maxsize self . deque : Deque [ T ] = deque ( maxlen = maxsize ) self . send_cv : Condition = Condition () self . recv_cv : Condition = Condition () self . closed : bool = False async def close ( self ) -> None : \"\"\"Close the channel. Any further attempts to [send()][frequenz.channels.Sender.send] data will return `False`. Receivers will still be able to drain the pending items on the channel, but after that, subsequent [receive()][frequenz.channels.Receiver.receive] calls will return `None` immediately. \"\"\" self . closed = True async with self . send_cv : self . send_cv . notify_all () async with self . recv_cv : self . recv_cv . notify_all () def get_sender ( self ) -> Sender [ T ]: \"\"\"Create a new sender. Returns: A Sender instance attached to the Anycast channel. \"\"\" return Sender ( self ) def get_receiver ( self ) -> Receiver [ T ]: \"\"\"Create a new receiver. Returns: A Receiver instance attached to the Anycast channel. \"\"\" return Receiver ( self )","title":"Anycast"},{"location":"reference/frequenz/channels/anycast/#frequenz.channels.anycast.Anycast-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/anycast/#frequenz.channels.anycast.Anycast.__init__","text":"Create an Anycast channel. PARAMETER DESCRIPTION maxsize Size of the channel's buffer. TYPE: int DEFAULT: 10 Source code in frequenz/channels/anycast.py 63 64 65 66 67 68 69 70 71 72 73 def __init__ ( self , maxsize : int = 10 ) -> None : \"\"\"Create an Anycast channel. Args: maxsize: Size of the channel's buffer. \"\"\" self . limit : int = maxsize self . deque : Deque [ T ] = deque ( maxlen = maxsize ) self . send_cv : Condition = Condition () self . recv_cv : Condition = Condition () self . closed : bool = False","title":"__init__()"},{"location":"reference/frequenz/channels/anycast/#frequenz.channels.anycast.Anycast.close","text":"Close the channel. Any further attempts to send() data will return False . Receivers will still be able to drain the pending items on the channel, but after that, subsequent receive() calls will return None immediately. Source code in frequenz/channels/anycast.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 async def close ( self ) -> None : \"\"\"Close the channel. Any further attempts to [send()][frequenz.channels.Sender.send] data will return `False`. Receivers will still be able to drain the pending items on the channel, but after that, subsequent [receive()][frequenz.channels.Receiver.receive] calls will return `None` immediately. \"\"\" self . closed = True async with self . send_cv : self . send_cv . notify_all () async with self . recv_cv : self . recv_cv . notify_all ()","title":"close()"},{"location":"reference/frequenz/channels/anycast/#frequenz.channels.anycast.Anycast.get_receiver","text":"Create a new receiver. RETURNS DESCRIPTION Receiver [ T ] A Receiver instance attached to the Anycast channel. Source code in frequenz/channels/anycast.py 101 102 103 104 105 106 107 def get_receiver ( self ) -> Receiver [ T ]: \"\"\"Create a new receiver. Returns: A Receiver instance attached to the Anycast channel. \"\"\" return Receiver ( self )","title":"get_receiver()"},{"location":"reference/frequenz/channels/anycast/#frequenz.channels.anycast.Anycast.get_sender","text":"Create a new sender. RETURNS DESCRIPTION Sender [ T ] A Sender instance attached to the Anycast channel. Source code in frequenz/channels/anycast.py 93 94 95 96 97 98 99 def get_sender ( self ) -> Sender [ T ]: \"\"\"Create a new sender. Returns: A Sender instance attached to the Anycast channel. \"\"\" return Sender ( self )","title":"get_sender()"},{"location":"reference/frequenz/channels/anycast/#frequenz.channels.anycast.Receiver","text":"Bases: BaseReceiver [ T ] A receiver to receive messages from an Anycast channel. Should not be created directly, but through the Anycast.get_receiver() method. Source code in frequenz/channels/anycast.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 class Receiver ( BaseReceiver [ T ]): \"\"\"A receiver to receive messages from an Anycast channel. Should not be created directly, but through the `Anycast.get_receiver()` method. \"\"\" def __init__ ( self , chan : Anycast [ T ]) -> None : \"\"\"Create a channel receiver. Args: chan: A reference to the channel that this receiver belongs to. \"\"\" self . _chan = chan async def receive ( self ) -> Optional [ T ]: \"\"\"Receive a message from the channel. Waits for an message to become available, and returns that message. When there are multiple receivers for the channel, only one receiver will receive each message. Returns: `None`, if the channel is closed, a message otherwise. \"\"\" while len ( self . _chan . deque ) == 0 : if self . _chan . closed : return None async with self . _chan . recv_cv : await self . _chan . recv_cv . wait () ret = self . _chan . deque . popleft () async with self . _chan . send_cv : self . _chan . send_cv . notify ( 1 ) return ret","title":"Receiver"},{"location":"reference/frequenz/channels/anycast/#frequenz.channels.anycast.Receiver-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/anycast/#frequenz.channels.anycast.Receiver.__init__","text":"Create a channel receiver. PARAMETER DESCRIPTION chan A reference to the channel that this receiver belongs to. TYPE: Anycast [ T ] Source code in frequenz/channels/anycast.py 158 159 160 161 162 163 164 def __init__ ( self , chan : Anycast [ T ]) -> None : \"\"\"Create a channel receiver. Args: chan: A reference to the channel that this receiver belongs to. \"\"\" self . _chan = chan","title":"__init__()"},{"location":"reference/frequenz/channels/anycast/#frequenz.channels.anycast.Receiver.receive","text":"Receive a message from the channel. Waits for an message to become available, and returns that message. When there are multiple receivers for the channel, only one receiver will receive each message. RETURNS DESCRIPTION Optional [ T ] None , if the channel is closed, a message otherwise. Source code in frequenz/channels/anycast.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 async def receive ( self ) -> Optional [ T ]: \"\"\"Receive a message from the channel. Waits for an message to become available, and returns that message. When there are multiple receivers for the channel, only one receiver will receive each message. Returns: `None`, if the channel is closed, a message otherwise. \"\"\" while len ( self . _chan . deque ) == 0 : if self . _chan . closed : return None async with self . _chan . recv_cv : await self . _chan . recv_cv . wait () ret = self . _chan . deque . popleft () async with self . _chan . send_cv : self . _chan . send_cv . notify ( 1 ) return ret","title":"receive()"},{"location":"reference/frequenz/channels/anycast/#frequenz.channels.anycast.Sender","text":"Bases: BaseSender [ T ] A sender to send messages to an Anycast channel. Should not be created directly, but through the Anycast.get_sender() method. Source code in frequenz/channels/anycast.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 class Sender ( BaseSender [ T ]): \"\"\"A sender to send messages to an Anycast channel. Should not be created directly, but through the `Anycast.get_sender()` method. \"\"\" def __init__ ( self , chan : Anycast [ T ]) -> None : \"\"\"Create a channel sender. Args: chan: A reference to the channel that this sender belongs to. \"\"\" self . _chan = chan async def send ( self , msg : T ) -> bool : \"\"\"Send a message across the channel. To send, this method inserts the message into the Anycast channel's buffer. If the channel's buffer is full, waits for messages to get consumed, until there's some free space available in the buffer. Each message will be received by exactly one receiver. Args: msg: The message to be sent. Returns: Whether the message was sent, based on whether the channel is open or not. \"\"\" if self . _chan . closed : return False while len ( self . _chan . deque ) == self . _chan . deque . maxlen : async with self . _chan . send_cv : await self . _chan . send_cv . wait () self . _chan . deque . append ( msg ) async with self . _chan . recv_cv : self . _chan . recv_cv . notify ( 1 ) return True","title":"Sender"},{"location":"reference/frequenz/channels/anycast/#frequenz.channels.anycast.Sender-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/anycast/#frequenz.channels.anycast.Sender.__init__","text":"Create a channel sender. PARAMETER DESCRIPTION chan A reference to the channel that this sender belongs to. TYPE: Anycast [ T ] Source code in frequenz/channels/anycast.py 117 118 119 120 121 122 123 def __init__ ( self , chan : Anycast [ T ]) -> None : \"\"\"Create a channel sender. Args: chan: A reference to the channel that this sender belongs to. \"\"\" self . _chan = chan","title":"__init__()"},{"location":"reference/frequenz/channels/anycast/#frequenz.channels.anycast.Sender.send","text":"Send a message across the channel. To send, this method inserts the message into the Anycast channel's buffer. If the channel's buffer is full, waits for messages to get consumed, until there's some free space available in the buffer. Each message will be received by exactly one receiver. PARAMETER DESCRIPTION msg The message to be sent. TYPE: T RETURNS DESCRIPTION bool Whether the message was sent, based on whether the channel is open or not. Source code in frequenz/channels/anycast.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 async def send ( self , msg : T ) -> bool : \"\"\"Send a message across the channel. To send, this method inserts the message into the Anycast channel's buffer. If the channel's buffer is full, waits for messages to get consumed, until there's some free space available in the buffer. Each message will be received by exactly one receiver. Args: msg: The message to be sent. Returns: Whether the message was sent, based on whether the channel is open or not. \"\"\" if self . _chan . closed : return False while len ( self . _chan . deque ) == self . _chan . deque . maxlen : async with self . _chan . send_cv : await self . _chan . send_cv . wait () self . _chan . deque . append ( msg ) async with self . _chan . recv_cv : self . _chan . recv_cv . notify ( 1 ) return True","title":"send()"},{"location":"reference/frequenz/channels/base_classes/","text":"frequenz.channels.base_classes \u00a4 Baseclasses for Channel Sender and Receiver. Classes \u00a4 frequenz.channels.base_classes.BufferedReceiver \u00a4 Bases: Receiver [ T ] A channel receiver with a buffer. Source code in frequenz/channels/base_classes.py 107 108 109 110 111 112 113 114 115 116 class BufferedReceiver ( Receiver [ T ]): \"\"\"A channel receiver with a buffer.\"\"\" @abstractmethod def enqueue ( self , msg : T ) -> None : \"\"\"Put a message into this buffered receiver's queue. Args: msg: The message to be added to the queue. \"\"\" Functions \u00a4 enqueue ( msg ) abstractmethod \u00a4 Put a message into this buffered receiver's queue. PARAMETER DESCRIPTION msg The message to be added to the queue. TYPE: T Source code in frequenz/channels/base_classes.py 110 111 112 113 114 115 116 @abstractmethod def enqueue ( self , msg : T ) -> None : \"\"\"Put a message into this buffered receiver's queue. Args: msg: The message to be added to the queue. \"\"\" frequenz.channels.base_classes.Peekable \u00a4 Bases: ABC , Generic [ T ] A channel peekable. A Peekable provides a peek() method that allows the user to get a peek at the latest value in the channel, without consuming anything. Source code in frequenz/channels/base_classes.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 class Peekable ( ABC , Generic [ T ]): \"\"\"A channel peekable. A Peekable provides a [peek()][frequenz.channels.Peekable] method that allows the user to get a peek at the latest value in the channel, without consuming anything. \"\"\" @abstractmethod def peek ( self ) -> Optional [ T ]: \"\"\"Return the latest value that was sent to the channel. Returns: The latest value received by the channel, and `None`, if nothing has been sent to the channel yet. \"\"\" Functions \u00a4 peek () abstractmethod \u00a4 Return the latest value that was sent to the channel. RETURNS DESCRIPTION Optional [ T ] The latest value received by the channel, and None , if nothing has been sent to the channel yet. Source code in frequenz/channels/base_classes.py 97 98 99 100 101 102 103 104 @abstractmethod def peek ( self ) -> Optional [ T ]: \"\"\"Return the latest value that was sent to the channel. Returns: The latest value received by the channel, and `None`, if nothing has been sent to the channel yet. \"\"\" frequenz.channels.base_classes.Receiver \u00a4 Bases: ABC , Generic [ T ] A channel Receiver. Source code in frequenz/channels/base_classes.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class Receiver ( ABC , Generic [ T ]): \"\"\"A channel Receiver.\"\"\" @abstractmethod async def receive ( self ) -> Optional [ T ]: \"\"\"Receive a message from the channel. Returns: `None`, if the channel is closed, a message otherwise. \"\"\" def __aiter__ ( self ) -> Receiver [ T ]: \"\"\"Initialize the async iterator over received values. Returns: `self`, since no extra setup is needed for the iterator. \"\"\" return self async def __anext__ ( self ) -> T : \"\"\"Await the next value in the async iteration over received values. Returns: The next value received. Raises: StopAsyncIteration: if we receive `None`, i.e. if the underlying channel is closed. \"\"\" received = await self . receive () if received is None : raise StopAsyncIteration return received def map ( self , call : Callable [[ T ], U ]) -> Receiver [ U ]: \"\"\"Return a receiver with `call` applied on incoming messages. Args: call: function to apply on incoming messages. Returns: A `Receiver` to read results of the given function from. \"\"\" return _Map ( self , call ) def into_peekable ( self ) -> Peekable [ T ]: \"\"\"Convert the `Receiver` implementation into a `Peekable`. Once this function has been called, the receiver will no longer be usable, and calling `receive` on the receiver will raise an exception. Raises: NotImplementedError: when a `Receiver` implementation doesn't have a custom `get_peekable` implementation. \"\"\" raise NotImplementedError ( \"This receiver does not implement `into_peekable`\" ) Functions \u00a4 __aiter__ () \u00a4 Initialize the async iterator over received values. RETURNS DESCRIPTION Receiver [ T ] self , since no extra setup is needed for the iterator. Source code in frequenz/channels/base_classes.py 42 43 44 45 46 47 48 def __aiter__ ( self ) -> Receiver [ T ]: \"\"\"Initialize the async iterator over received values. Returns: `self`, since no extra setup is needed for the iterator. \"\"\" return self __anext__ () async \u00a4 Await the next value in the async iteration over received values. RETURNS DESCRIPTION T The next value received. RAISES DESCRIPTION StopAsyncIteration if we receive None , i.e. if the underlying channel is closed. Source code in frequenz/channels/base_classes.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 async def __anext__ ( self ) -> T : \"\"\"Await the next value in the async iteration over received values. Returns: The next value received. Raises: StopAsyncIteration: if we receive `None`, i.e. if the underlying channel is closed. \"\"\" received = await self . receive () if received is None : raise StopAsyncIteration return received into_peekable () \u00a4 Convert the Receiver implementation into a Peekable . Once this function has been called, the receiver will no longer be usable, and calling receive on the receiver will raise an exception. RAISES DESCRIPTION NotImplementedError when a Receiver implementation doesn't have a custom get_peekable implementation. Source code in frequenz/channels/base_classes.py 76 77 78 79 80 81 82 83 84 85 86 def into_peekable ( self ) -> Peekable [ T ]: \"\"\"Convert the `Receiver` implementation into a `Peekable`. Once this function has been called, the receiver will no longer be usable, and calling `receive` on the receiver will raise an exception. Raises: NotImplementedError: when a `Receiver` implementation doesn't have a custom `get_peekable` implementation. \"\"\" raise NotImplementedError ( \"This receiver does not implement `into_peekable`\" ) map ( call ) \u00a4 Return a receiver with call applied on incoming messages. PARAMETER DESCRIPTION call function to apply on incoming messages. TYPE: Callable [[ T ], U ] RETURNS DESCRIPTION Receiver [ U ] A Receiver to read results of the given function from. Source code in frequenz/channels/base_classes.py 65 66 67 68 69 70 71 72 73 74 def map ( self , call : Callable [[ T ], U ]) -> Receiver [ U ]: \"\"\"Return a receiver with `call` applied on incoming messages. Args: call: function to apply on incoming messages. Returns: A `Receiver` to read results of the given function from. \"\"\" return _Map ( self , call ) receive () async abstractmethod \u00a4 Receive a message from the channel. RETURNS DESCRIPTION Optional [ T ] None , if the channel is closed, a message otherwise. Source code in frequenz/channels/base_classes.py 34 35 36 37 38 39 40 @abstractmethod async def receive ( self ) -> Optional [ T ]: \"\"\"Receive a message from the channel. Returns: `None`, if the channel is closed, a message otherwise. \"\"\" frequenz.channels.base_classes.Sender \u00a4 Bases: ABC , Generic [ T ] A channel Sender. Source code in frequenz/channels/base_classes.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Sender ( ABC , Generic [ T ]): \"\"\"A channel Sender.\"\"\" @abstractmethod async def send ( self , msg : T ) -> bool : \"\"\"Send a message to the channel. Args: msg: The message to be sent. Returns: Whether the message was sent, based on whether the channel is open or not. \"\"\" Functions \u00a4 send ( msg ) async abstractmethod \u00a4 Send a message to the channel. PARAMETER DESCRIPTION msg The message to be sent. TYPE: T RETURNS DESCRIPTION bool Whether the message was sent, based on whether the channel is open or not. Source code in frequenz/channels/base_classes.py 18 19 20 21 22 23 24 25 26 27 28 @abstractmethod async def send ( self , msg : T ) -> bool : \"\"\"Send a message to the channel. Args: msg: The message to be sent. Returns: Whether the message was sent, based on whether the channel is open or not. \"\"\"","title":"base_classes"},{"location":"reference/frequenz/channels/base_classes/#frequenz.channels.base_classes","text":"Baseclasses for Channel Sender and Receiver.","title":"base_classes"},{"location":"reference/frequenz/channels/base_classes/#frequenz.channels.base_classes-classes","text":"","title":"Classes"},{"location":"reference/frequenz/channels/base_classes/#frequenz.channels.base_classes.BufferedReceiver","text":"Bases: Receiver [ T ] A channel receiver with a buffer. Source code in frequenz/channels/base_classes.py 107 108 109 110 111 112 113 114 115 116 class BufferedReceiver ( Receiver [ T ]): \"\"\"A channel receiver with a buffer.\"\"\" @abstractmethod def enqueue ( self , msg : T ) -> None : \"\"\"Put a message into this buffered receiver's queue. Args: msg: The message to be added to the queue. \"\"\"","title":"BufferedReceiver"},{"location":"reference/frequenz/channels/base_classes/#frequenz.channels.base_classes.BufferedReceiver-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/base_classes/#frequenz.channels.base_classes.BufferedReceiver.enqueue","text":"Put a message into this buffered receiver's queue. PARAMETER DESCRIPTION msg The message to be added to the queue. TYPE: T Source code in frequenz/channels/base_classes.py 110 111 112 113 114 115 116 @abstractmethod def enqueue ( self , msg : T ) -> None : \"\"\"Put a message into this buffered receiver's queue. Args: msg: The message to be added to the queue. \"\"\"","title":"enqueue()"},{"location":"reference/frequenz/channels/base_classes/#frequenz.channels.base_classes.Peekable","text":"Bases: ABC , Generic [ T ] A channel peekable. A Peekable provides a peek() method that allows the user to get a peek at the latest value in the channel, without consuming anything. Source code in frequenz/channels/base_classes.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 class Peekable ( ABC , Generic [ T ]): \"\"\"A channel peekable. A Peekable provides a [peek()][frequenz.channels.Peekable] method that allows the user to get a peek at the latest value in the channel, without consuming anything. \"\"\" @abstractmethod def peek ( self ) -> Optional [ T ]: \"\"\"Return the latest value that was sent to the channel. Returns: The latest value received by the channel, and `None`, if nothing has been sent to the channel yet. \"\"\"","title":"Peekable"},{"location":"reference/frequenz/channels/base_classes/#frequenz.channels.base_classes.Peekable-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/base_classes/#frequenz.channels.base_classes.Peekable.peek","text":"Return the latest value that was sent to the channel. RETURNS DESCRIPTION Optional [ T ] The latest value received by the channel, and None , if nothing has been sent to the channel yet. Source code in frequenz/channels/base_classes.py 97 98 99 100 101 102 103 104 @abstractmethod def peek ( self ) -> Optional [ T ]: \"\"\"Return the latest value that was sent to the channel. Returns: The latest value received by the channel, and `None`, if nothing has been sent to the channel yet. \"\"\"","title":"peek()"},{"location":"reference/frequenz/channels/base_classes/#frequenz.channels.base_classes.Receiver","text":"Bases: ABC , Generic [ T ] A channel Receiver. Source code in frequenz/channels/base_classes.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class Receiver ( ABC , Generic [ T ]): \"\"\"A channel Receiver.\"\"\" @abstractmethod async def receive ( self ) -> Optional [ T ]: \"\"\"Receive a message from the channel. Returns: `None`, if the channel is closed, a message otherwise. \"\"\" def __aiter__ ( self ) -> Receiver [ T ]: \"\"\"Initialize the async iterator over received values. Returns: `self`, since no extra setup is needed for the iterator. \"\"\" return self async def __anext__ ( self ) -> T : \"\"\"Await the next value in the async iteration over received values. Returns: The next value received. Raises: StopAsyncIteration: if we receive `None`, i.e. if the underlying channel is closed. \"\"\" received = await self . receive () if received is None : raise StopAsyncIteration return received def map ( self , call : Callable [[ T ], U ]) -> Receiver [ U ]: \"\"\"Return a receiver with `call` applied on incoming messages. Args: call: function to apply on incoming messages. Returns: A `Receiver` to read results of the given function from. \"\"\" return _Map ( self , call ) def into_peekable ( self ) -> Peekable [ T ]: \"\"\"Convert the `Receiver` implementation into a `Peekable`. Once this function has been called, the receiver will no longer be usable, and calling `receive` on the receiver will raise an exception. Raises: NotImplementedError: when a `Receiver` implementation doesn't have a custom `get_peekable` implementation. \"\"\" raise NotImplementedError ( \"This receiver does not implement `into_peekable`\" )","title":"Receiver"},{"location":"reference/frequenz/channels/base_classes/#frequenz.channels.base_classes.Receiver-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/base_classes/#frequenz.channels.base_classes.Receiver.__aiter__","text":"Initialize the async iterator over received values. RETURNS DESCRIPTION Receiver [ T ] self , since no extra setup is needed for the iterator. Source code in frequenz/channels/base_classes.py 42 43 44 45 46 47 48 def __aiter__ ( self ) -> Receiver [ T ]: \"\"\"Initialize the async iterator over received values. Returns: `self`, since no extra setup is needed for the iterator. \"\"\" return self","title":"__aiter__()"},{"location":"reference/frequenz/channels/base_classes/#frequenz.channels.base_classes.Receiver.__anext__","text":"Await the next value in the async iteration over received values. RETURNS DESCRIPTION T The next value received. RAISES DESCRIPTION StopAsyncIteration if we receive None , i.e. if the underlying channel is closed. Source code in frequenz/channels/base_classes.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 async def __anext__ ( self ) -> T : \"\"\"Await the next value in the async iteration over received values. Returns: The next value received. Raises: StopAsyncIteration: if we receive `None`, i.e. if the underlying channel is closed. \"\"\" received = await self . receive () if received is None : raise StopAsyncIteration return received","title":"__anext__()"},{"location":"reference/frequenz/channels/base_classes/#frequenz.channels.base_classes.Receiver.into_peekable","text":"Convert the Receiver implementation into a Peekable . Once this function has been called, the receiver will no longer be usable, and calling receive on the receiver will raise an exception. RAISES DESCRIPTION NotImplementedError when a Receiver implementation doesn't have a custom get_peekable implementation. Source code in frequenz/channels/base_classes.py 76 77 78 79 80 81 82 83 84 85 86 def into_peekable ( self ) -> Peekable [ T ]: \"\"\"Convert the `Receiver` implementation into a `Peekable`. Once this function has been called, the receiver will no longer be usable, and calling `receive` on the receiver will raise an exception. Raises: NotImplementedError: when a `Receiver` implementation doesn't have a custom `get_peekable` implementation. \"\"\" raise NotImplementedError ( \"This receiver does not implement `into_peekable`\" )","title":"into_peekable()"},{"location":"reference/frequenz/channels/base_classes/#frequenz.channels.base_classes.Receiver.map","text":"Return a receiver with call applied on incoming messages. PARAMETER DESCRIPTION call function to apply on incoming messages. TYPE: Callable [[ T ], U ] RETURNS DESCRIPTION Receiver [ U ] A Receiver to read results of the given function from. Source code in frequenz/channels/base_classes.py 65 66 67 68 69 70 71 72 73 74 def map ( self , call : Callable [[ T ], U ]) -> Receiver [ U ]: \"\"\"Return a receiver with `call` applied on incoming messages. Args: call: function to apply on incoming messages. Returns: A `Receiver` to read results of the given function from. \"\"\" return _Map ( self , call )","title":"map()"},{"location":"reference/frequenz/channels/base_classes/#frequenz.channels.base_classes.Receiver.receive","text":"Receive a message from the channel. RETURNS DESCRIPTION Optional [ T ] None , if the channel is closed, a message otherwise. Source code in frequenz/channels/base_classes.py 34 35 36 37 38 39 40 @abstractmethod async def receive ( self ) -> Optional [ T ]: \"\"\"Receive a message from the channel. Returns: `None`, if the channel is closed, a message otherwise. \"\"\"","title":"receive()"},{"location":"reference/frequenz/channels/base_classes/#frequenz.channels.base_classes.Sender","text":"Bases: ABC , Generic [ T ] A channel Sender. Source code in frequenz/channels/base_classes.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Sender ( ABC , Generic [ T ]): \"\"\"A channel Sender.\"\"\" @abstractmethod async def send ( self , msg : T ) -> bool : \"\"\"Send a message to the channel. Args: msg: The message to be sent. Returns: Whether the message was sent, based on whether the channel is open or not. \"\"\"","title":"Sender"},{"location":"reference/frequenz/channels/base_classes/#frequenz.channels.base_classes.Sender-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/base_classes/#frequenz.channels.base_classes.Sender.send","text":"Send a message to the channel. PARAMETER DESCRIPTION msg The message to be sent. TYPE: T RETURNS DESCRIPTION bool Whether the message was sent, based on whether the channel is open or not. Source code in frequenz/channels/base_classes.py 18 19 20 21 22 23 24 25 26 27 28 @abstractmethod async def send ( self , msg : T ) -> bool : \"\"\"Send a message to the channel. Args: msg: The message to be sent. Returns: Whether the message was sent, based on whether the channel is open or not. \"\"\"","title":"send()"},{"location":"reference/frequenz/channels/bidirectional/","text":"frequenz.channels.bidirectional \u00a4 An abstraction to provide bi-directional communication between actors. Classes \u00a4 frequenz.channels.bidirectional.Bidirectional \u00a4 Bases: Generic [ T , U ] A wrapper class for simulating bidirectional channels. Source code in frequenz/channels/bidirectional.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Bidirectional ( Generic [ T , U ]): \"\"\"A wrapper class for simulating bidirectional channels.\"\"\" def __init__ ( self , client_id : str , service_id : str ) -> None : \"\"\"Create a `Bidirectional` instance. Args: client_id: A name for the client, used to name the channels. service_id: A name for the service end of the channels. \"\"\" self . _client_id = client_id self . _request_channel : Broadcast [ T ] = Broadcast ( f \"req_ { service_id } _ { client_id } \" ) self . _response_channel : Broadcast [ U ] = Broadcast ( f \"resp_ { service_id } _ { client_id } \" ) self . _client_handle = BidirectionalHandle ( self . _request_channel . get_sender (), self . _response_channel . get_receiver (), ) self . _service_handle = BidirectionalHandle ( self . _response_channel . get_sender (), self . _request_channel . get_receiver (), ) @property def client_handle ( self ) -> BidirectionalHandle [ T , U ]: \"\"\"Get a BidirectionalHandle for the client to use. Returns: Object to send/receive messages with. \"\"\" return self . _client_handle @property def service_handle ( self ) -> BidirectionalHandle [ U , T ]: \"\"\"Get a `BidirectionalHandle` for the service to use. Returns: Object to send/receive messages with. \"\"\" return self . _service_handle Functions \u00a4 __init__ ( client_id , service_id ) \u00a4 Create a Bidirectional instance. PARAMETER DESCRIPTION client_id A name for the client, used to name the channels. TYPE: str service_id A name for the service end of the channels. TYPE: str Source code in frequenz/channels/bidirectional.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , client_id : str , service_id : str ) -> None : \"\"\"Create a `Bidirectional` instance. Args: client_id: A name for the client, used to name the channels. service_id: A name for the service end of the channels. \"\"\" self . _client_id = client_id self . _request_channel : Broadcast [ T ] = Broadcast ( f \"req_ { service_id } _ { client_id } \" ) self . _response_channel : Broadcast [ U ] = Broadcast ( f \"resp_ { service_id } _ { client_id } \" ) self . _client_handle = BidirectionalHandle ( self . _request_channel . get_sender (), self . _response_channel . get_receiver (), ) self . _service_handle = BidirectionalHandle ( self . _response_channel . get_sender (), self . _request_channel . get_receiver (), ) client_handle () property \u00a4 Get a BidirectionalHandle for the client to use. RETURNS DESCRIPTION BidirectionalHandle [ T , U ] Object to send/receive messages with. Source code in frequenz/channels/bidirectional.py 39 40 41 42 43 44 45 46 @property def client_handle ( self ) -> BidirectionalHandle [ T , U ]: \"\"\"Get a BidirectionalHandle for the client to use. Returns: Object to send/receive messages with. \"\"\" return self . _client_handle service_handle () property \u00a4 Get a BidirectionalHandle for the service to use. RETURNS DESCRIPTION BidirectionalHandle [ U , T ] Object to send/receive messages with. Source code in frequenz/channels/bidirectional.py 48 49 50 51 52 53 54 55 @property def service_handle ( self ) -> BidirectionalHandle [ U , T ]: \"\"\"Get a `BidirectionalHandle` for the service to use. Returns: Object to send/receive messages with. \"\"\" return self . _service_handle frequenz.channels.bidirectional.BidirectionalHandle \u00a4 Bases: Sender [ T ] , Receiver [ U ] A handle to a Bidirectional instance. It can be used to send/receive values between the client and service. Source code in frequenz/channels/bidirectional.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class BidirectionalHandle ( Sender [ T ], Receiver [ U ]): \"\"\"A handle to a [Bidirectional][frequenz.channels.Bidirectional] instance. It can be used to send/receive values between the client and service. \"\"\" def __init__ ( self , sender : Sender [ T ], receiver : Receiver [ U ]) -> None : \"\"\"Create a `BidirectionalHandle` instance. Args: sender: A sender to send values with. receiver: A receiver to receive values from. \"\"\" self . _sender = sender self . _receiver = receiver async def send ( self , msg : T ) -> bool : \"\"\"Send a value to the other side. Args: msg: The value to send. Returns: Whether the send was successful or not. \"\"\" return await self . _sender . send ( msg ) async def receive ( self ) -> Optional [ U ]: \"\"\"Receive a value from the other side. Returns: Received value, or `None` if the channels are closed. \"\"\" return await self . _receiver . receive () Functions \u00a4 __init__ ( sender , receiver ) \u00a4 Create a BidirectionalHandle instance. PARAMETER DESCRIPTION sender A sender to send values with. TYPE: Sender [ T ] receiver A receiver to receive values from. TYPE: Receiver [ U ] Source code in frequenz/channels/bidirectional.py 64 65 66 67 68 69 70 71 72 def __init__ ( self , sender : Sender [ T ], receiver : Receiver [ U ]) -> None : \"\"\"Create a `BidirectionalHandle` instance. Args: sender: A sender to send values with. receiver: A receiver to receive values from. \"\"\" self . _sender = sender self . _receiver = receiver receive () async \u00a4 Receive a value from the other side. RETURNS DESCRIPTION Optional [ U ] Received value, or None if the channels are closed. Source code in frequenz/channels/bidirectional.py 85 86 87 88 89 90 91 async def receive ( self ) -> Optional [ U ]: \"\"\"Receive a value from the other side. Returns: Received value, or `None` if the channels are closed. \"\"\" return await self . _receiver . receive () send ( msg ) async \u00a4 Send a value to the other side. PARAMETER DESCRIPTION msg The value to send. TYPE: T RETURNS DESCRIPTION bool Whether the send was successful or not. Source code in frequenz/channels/bidirectional.py 74 75 76 77 78 79 80 81 82 83 async def send ( self , msg : T ) -> bool : \"\"\"Send a value to the other side. Args: msg: The value to send. Returns: Whether the send was successful or not. \"\"\" return await self . _sender . send ( msg )","title":"bidirectional"},{"location":"reference/frequenz/channels/bidirectional/#frequenz.channels.bidirectional","text":"An abstraction to provide bi-directional communication between actors.","title":"bidirectional"},{"location":"reference/frequenz/channels/bidirectional/#frequenz.channels.bidirectional-classes","text":"","title":"Classes"},{"location":"reference/frequenz/channels/bidirectional/#frequenz.channels.bidirectional.Bidirectional","text":"Bases: Generic [ T , U ] A wrapper class for simulating bidirectional channels. Source code in frequenz/channels/bidirectional.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Bidirectional ( Generic [ T , U ]): \"\"\"A wrapper class for simulating bidirectional channels.\"\"\" def __init__ ( self , client_id : str , service_id : str ) -> None : \"\"\"Create a `Bidirectional` instance. Args: client_id: A name for the client, used to name the channels. service_id: A name for the service end of the channels. \"\"\" self . _client_id = client_id self . _request_channel : Broadcast [ T ] = Broadcast ( f \"req_ { service_id } _ { client_id } \" ) self . _response_channel : Broadcast [ U ] = Broadcast ( f \"resp_ { service_id } _ { client_id } \" ) self . _client_handle = BidirectionalHandle ( self . _request_channel . get_sender (), self . _response_channel . get_receiver (), ) self . _service_handle = BidirectionalHandle ( self . _response_channel . get_sender (), self . _request_channel . get_receiver (), ) @property def client_handle ( self ) -> BidirectionalHandle [ T , U ]: \"\"\"Get a BidirectionalHandle for the client to use. Returns: Object to send/receive messages with. \"\"\" return self . _client_handle @property def service_handle ( self ) -> BidirectionalHandle [ U , T ]: \"\"\"Get a `BidirectionalHandle` for the service to use. Returns: Object to send/receive messages with. \"\"\" return self . _service_handle","title":"Bidirectional"},{"location":"reference/frequenz/channels/bidirectional/#frequenz.channels.bidirectional.Bidirectional-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/bidirectional/#frequenz.channels.bidirectional.Bidirectional.__init__","text":"Create a Bidirectional instance. PARAMETER DESCRIPTION client_id A name for the client, used to name the channels. TYPE: str service_id A name for the service end of the channels. TYPE: str Source code in frequenz/channels/bidirectional.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , client_id : str , service_id : str ) -> None : \"\"\"Create a `Bidirectional` instance. Args: client_id: A name for the client, used to name the channels. service_id: A name for the service end of the channels. \"\"\" self . _client_id = client_id self . _request_channel : Broadcast [ T ] = Broadcast ( f \"req_ { service_id } _ { client_id } \" ) self . _response_channel : Broadcast [ U ] = Broadcast ( f \"resp_ { service_id } _ { client_id } \" ) self . _client_handle = BidirectionalHandle ( self . _request_channel . get_sender (), self . _response_channel . get_receiver (), ) self . _service_handle = BidirectionalHandle ( self . _response_channel . get_sender (), self . _request_channel . get_receiver (), )","title":"__init__()"},{"location":"reference/frequenz/channels/bidirectional/#frequenz.channels.bidirectional.Bidirectional.client_handle","text":"Get a BidirectionalHandle for the client to use. RETURNS DESCRIPTION BidirectionalHandle [ T , U ] Object to send/receive messages with. Source code in frequenz/channels/bidirectional.py 39 40 41 42 43 44 45 46 @property def client_handle ( self ) -> BidirectionalHandle [ T , U ]: \"\"\"Get a BidirectionalHandle for the client to use. Returns: Object to send/receive messages with. \"\"\" return self . _client_handle","title":"client_handle()"},{"location":"reference/frequenz/channels/bidirectional/#frequenz.channels.bidirectional.Bidirectional.service_handle","text":"Get a BidirectionalHandle for the service to use. RETURNS DESCRIPTION BidirectionalHandle [ U , T ] Object to send/receive messages with. Source code in frequenz/channels/bidirectional.py 48 49 50 51 52 53 54 55 @property def service_handle ( self ) -> BidirectionalHandle [ U , T ]: \"\"\"Get a `BidirectionalHandle` for the service to use. Returns: Object to send/receive messages with. \"\"\" return self . _service_handle","title":"service_handle()"},{"location":"reference/frequenz/channels/bidirectional/#frequenz.channels.bidirectional.BidirectionalHandle","text":"Bases: Sender [ T ] , Receiver [ U ] A handle to a Bidirectional instance. It can be used to send/receive values between the client and service. Source code in frequenz/channels/bidirectional.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class BidirectionalHandle ( Sender [ T ], Receiver [ U ]): \"\"\"A handle to a [Bidirectional][frequenz.channels.Bidirectional] instance. It can be used to send/receive values between the client and service. \"\"\" def __init__ ( self , sender : Sender [ T ], receiver : Receiver [ U ]) -> None : \"\"\"Create a `BidirectionalHandle` instance. Args: sender: A sender to send values with. receiver: A receiver to receive values from. \"\"\" self . _sender = sender self . _receiver = receiver async def send ( self , msg : T ) -> bool : \"\"\"Send a value to the other side. Args: msg: The value to send. Returns: Whether the send was successful or not. \"\"\" return await self . _sender . send ( msg ) async def receive ( self ) -> Optional [ U ]: \"\"\"Receive a value from the other side. Returns: Received value, or `None` if the channels are closed. \"\"\" return await self . _receiver . receive ()","title":"BidirectionalHandle"},{"location":"reference/frequenz/channels/bidirectional/#frequenz.channels.bidirectional.BidirectionalHandle-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/bidirectional/#frequenz.channels.bidirectional.BidirectionalHandle.__init__","text":"Create a BidirectionalHandle instance. PARAMETER DESCRIPTION sender A sender to send values with. TYPE: Sender [ T ] receiver A receiver to receive values from. TYPE: Receiver [ U ] Source code in frequenz/channels/bidirectional.py 64 65 66 67 68 69 70 71 72 def __init__ ( self , sender : Sender [ T ], receiver : Receiver [ U ]) -> None : \"\"\"Create a `BidirectionalHandle` instance. Args: sender: A sender to send values with. receiver: A receiver to receive values from. \"\"\" self . _sender = sender self . _receiver = receiver","title":"__init__()"},{"location":"reference/frequenz/channels/bidirectional/#frequenz.channels.bidirectional.BidirectionalHandle.receive","text":"Receive a value from the other side. RETURNS DESCRIPTION Optional [ U ] Received value, or None if the channels are closed. Source code in frequenz/channels/bidirectional.py 85 86 87 88 89 90 91 async def receive ( self ) -> Optional [ U ]: \"\"\"Receive a value from the other side. Returns: Received value, or `None` if the channels are closed. \"\"\" return await self . _receiver . receive ()","title":"receive()"},{"location":"reference/frequenz/channels/bidirectional/#frequenz.channels.bidirectional.BidirectionalHandle.send","text":"Send a value to the other side. PARAMETER DESCRIPTION msg The value to send. TYPE: T RETURNS DESCRIPTION bool Whether the send was successful or not. Source code in frequenz/channels/bidirectional.py 74 75 76 77 78 79 80 81 82 83 async def send ( self , msg : T ) -> bool : \"\"\"Send a value to the other side. Args: msg: The value to send. Returns: Whether the send was successful or not. \"\"\" return await self . _sender . send ( msg )","title":"send()"},{"location":"reference/frequenz/channels/broadcast/","text":"frequenz.channels.broadcast \u00a4 A channel to broadcast messages to all receivers. Classes \u00a4 frequenz.channels.broadcast.Broadcast \u00a4 Bases: Generic [ T ] A channel to broadcast messages to multiple receivers. Broadcast channels can have multiple senders and multiple receivers. Each message sent through any of the senders is received by all of the receivers. Internally, a broadcast receiver's buffer is implemented with just append/pop operations on either side of a deque , which are thread-safe. Because of this, Broadcast channels are thread-safe. When there are multiple channel receivers, they can be awaited simultaneously using Select , Merge or MergeNamed . Example async def send ( sender : channel . Sender ) -> None : while True : next = random . randint ( 3 , 17 ) print ( f \"sending: { next } \" ) await sender . send ( next ) async def recv ( id : int , receiver : channel . Receiver ) -> None : while True : next = await receiver . receive () print ( f \"receiver_ { id } received { next } \" ) await asyncio . sleep ( 0.1 ) # sleep (or work) with the data bcast = channel . Broadcast () sender = bcast . get_sender () receiver_1 = bcast . get_receiver () asyncio . create_task ( send ( sender )) await recv ( 1 , receiver_1 ) Check the tests and benchmarks directories for more examples. Source code in frequenz/channels/broadcast.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class Broadcast ( Generic [ T ]): \"\"\"A channel to broadcast messages to multiple receivers. `Broadcast` channels can have multiple senders and multiple receivers. Each message sent through any of the senders is received by all of the receivers. Internally, a broadcast receiver's buffer is implemented with just append/pop operations on either side of a [deque][collections.deque], which are thread-safe. Because of this, `Broadcast` channels are thread-safe. When there are multiple channel receivers, they can be awaited simultaneously using [Select][frequenz.channels.Select], [Merge][frequenz.channels.Merge] or [MergeNamed][frequenz.channels.MergeNamed]. Example: ``` python async def send(sender: channel.Sender) -> None: while True: next = random.randint(3, 17) print(f\"sending: {next}\") await sender.send(next) async def recv(id: int, receiver: channel.Receiver) -> None: while True: next = await receiver.receive() print(f\"receiver_{id} received {next}\") await asyncio.sleep(0.1) # sleep (or work) with the data bcast = channel.Broadcast() sender = bcast.get_sender() receiver_1 = bcast.get_receiver() asyncio.create_task(send(sender)) await recv(1, receiver_1) ``` Check the `tests` and `benchmarks` directories for more examples. \"\"\" def __init__ ( self , name : str , resend_latest : bool = False ) -> None : \"\"\"Create a Broadcast channel. Args: name: A name for the broadcast channel, typically based on the type of data sent through it. Used to identify the channel in the logs. resend_latest: When True, every time a new receiver is created with `get_receiver`, it will automatically get sent the latest value on the channel. This allows new receivers on slow streams to get the latest value as soon as they are created, without having to wait for the next message on the channel to arrive. \"\"\" self . name : str = name self . _resend_latest = resend_latest self . recv_cv : Condition = Condition () self . receivers : Dict [ UUID , Receiver [ T ]] = {} self . closed : bool = False self . _latest : Optional [ T ] = None async def close ( self ) -> None : \"\"\"Close the Broadcast channel. Any further attempts to [send()][frequenz.channels.Sender.send] data will return `False`. Receivers will still be able to drain the pending items on their queues, but after that, subsequent [receive()][frequenz.channels.Receiver.receive] calls will return `None` immediately. \"\"\" self . _latest = None self . closed = True async with self . recv_cv : self . recv_cv . notify_all () def _drop_receiver ( self , uuid : UUID ) -> None : \"\"\"Drop a specific receiver from the list of broadcast receivers. Called from the destructors of receivers. Args: uuid: a uuid identifying the receiver to be dropped. \"\"\" if uuid in self . receivers : del self . receivers [ uuid ] def get_sender ( self ) -> Sender [ T ]: \"\"\"Create a new broadcast sender. Returns: A Sender instance attached to the broadcast channel. \"\"\" return Sender ( self ) def get_receiver ( self , name : Optional [ str ] = None , maxsize : int = 50 ) -> Receiver [ T ]: \"\"\"Create a new broadcast receiver. Broadcast receivers have their own buffer, and when messages are not being consumed fast enough and the buffer fills up, old messages will get dropped just in this receiver. Args: name: A name to identify the receiver in the logs. maxsize: Size of the receiver's buffer. Returns: A Receiver instance attached to the broadcast channel. \"\"\" uuid = uuid4 () if name is None : name = str ( uuid ) recv : Receiver [ T ] = Receiver ( uuid , name , maxsize , self ) self . receivers [ uuid ] = recv if self . _resend_latest and self . _latest is not None : recv . enqueue ( self . _latest ) return recv def get_peekable ( self ) -> Peekable [ T ]: \"\"\"Create a new Peekable for the broadcast channel. A Peekable provides a [peek()][frequenz.channels.Peekable.peek] method that allows the user to get a peek at the latest value in the channel, without consuming anything. Returns: A Peekable to peek into the broadcast channel with. \"\"\" return Peekable ( self ) Functions \u00a4 __init__ ( name , resend_latest = False ) \u00a4 Create a Broadcast channel. PARAMETER DESCRIPTION name A name for the broadcast channel, typically based on the type of data sent through it. Used to identify the channel in the logs. TYPE: str resend_latest When True, every time a new receiver is created with get_receiver , it will automatically get sent the latest value on the channel. This allows new receivers on slow streams to get the latest value as soon as they are created, without having to wait for the next message on the channel to arrive. TYPE: bool DEFAULT: False Source code in frequenz/channels/broadcast.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def __init__ ( self , name : str , resend_latest : bool = False ) -> None : \"\"\"Create a Broadcast channel. Args: name: A name for the broadcast channel, typically based on the type of data sent through it. Used to identify the channel in the logs. resend_latest: When True, every time a new receiver is created with `get_receiver`, it will automatically get sent the latest value on the channel. This allows new receivers on slow streams to get the latest value as soon as they are created, without having to wait for the next message on the channel to arrive. \"\"\" self . name : str = name self . _resend_latest = resend_latest self . recv_cv : Condition = Condition () self . receivers : Dict [ UUID , Receiver [ T ]] = {} self . closed : bool = False self . _latest : Optional [ T ] = None close () async \u00a4 Close the Broadcast channel. Any further attempts to send() data will return False . Receivers will still be able to drain the pending items on their queues, but after that, subsequent receive() calls will return None immediately. Source code in frequenz/channels/broadcast.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 async def close ( self ) -> None : \"\"\"Close the Broadcast channel. Any further attempts to [send()][frequenz.channels.Sender.send] data will return `False`. Receivers will still be able to drain the pending items on their queues, but after that, subsequent [receive()][frequenz.channels.Receiver.receive] calls will return `None` immediately. \"\"\" self . _latest = None self . closed = True async with self . recv_cv : self . recv_cv . notify_all () get_peekable () \u00a4 Create a new Peekable for the broadcast channel. A Peekable provides a peek() method that allows the user to get a peek at the latest value in the channel, without consuming anything. RETURNS DESCRIPTION Peekable [ T ] A Peekable to peek into the broadcast channel with. Source code in frequenz/channels/broadcast.py 148 149 150 151 152 153 154 155 156 157 158 def get_peekable ( self ) -> Peekable [ T ]: \"\"\"Create a new Peekable for the broadcast channel. A Peekable provides a [peek()][frequenz.channels.Peekable.peek] method that allows the user to get a peek at the latest value in the channel, without consuming anything. Returns: A Peekable to peek into the broadcast channel with. \"\"\" return Peekable ( self ) get_receiver ( name = None , maxsize = 50 ) \u00a4 Create a new broadcast receiver. Broadcast receivers have their own buffer, and when messages are not being consumed fast enough and the buffer fills up, old messages will get dropped just in this receiver. PARAMETER DESCRIPTION name A name to identify the receiver in the logs. TYPE: Optional [ str ] DEFAULT: None maxsize Size of the receiver's buffer. TYPE: int DEFAULT: 50 RETURNS DESCRIPTION Receiver [ T ] A Receiver instance attached to the broadcast channel. Source code in frequenz/channels/broadcast.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def get_receiver ( self , name : Optional [ str ] = None , maxsize : int = 50 ) -> Receiver [ T ]: \"\"\"Create a new broadcast receiver. Broadcast receivers have their own buffer, and when messages are not being consumed fast enough and the buffer fills up, old messages will get dropped just in this receiver. Args: name: A name to identify the receiver in the logs. maxsize: Size of the receiver's buffer. Returns: A Receiver instance attached to the broadcast channel. \"\"\" uuid = uuid4 () if name is None : name = str ( uuid ) recv : Receiver [ T ] = Receiver ( uuid , name , maxsize , self ) self . receivers [ uuid ] = recv if self . _resend_latest and self . _latest is not None : recv . enqueue ( self . _latest ) return recv get_sender () \u00a4 Create a new broadcast sender. RETURNS DESCRIPTION Sender [ T ] A Sender instance attached to the broadcast channel. Source code in frequenz/channels/broadcast.py 115 116 117 118 119 120 121 def get_sender ( self ) -> Sender [ T ]: \"\"\"Create a new broadcast sender. Returns: A Sender instance attached to the broadcast channel. \"\"\" return Sender ( self ) frequenz.channels.broadcast.Peekable \u00a4 Bases: BasePeekable [ T ] A Peekable to peek into broadcast channels. A Peekable provides a peek() method that allows the user to get a peek at the latest value in the channel, without consuming anything. Source code in frequenz/channels/broadcast.py 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 class Peekable ( BasePeekable [ T ]): \"\"\"A Peekable to peek into broadcast channels. A Peekable provides a [peek()][frequenz.channels.Peekable] method that allows the user to get a peek at the latest value in the channel, without consuming anything. \"\"\" def __init__ ( self , chan : Broadcast [ T ]) -> None : \"\"\"Create a `Peekable` instance. Args: chan: The broadcast channel this Peekable will try to peek into. \"\"\" self . _chan = chan def peek ( self ) -> Optional [ T ]: \"\"\"Return the latest value that was sent to the channel. Returns: The latest value received by the channel, and `None`, if nothing has been sent to the channel yet, or if the channel is closed. \"\"\" return self . _chan . _latest # pylint: disable=protected-access Functions \u00a4 __init__ ( chan ) \u00a4 Create a Peekable instance. PARAMETER DESCRIPTION chan The broadcast channel this Peekable will try to peek into. TYPE: Broadcast [ T ] Source code in frequenz/channels/broadcast.py 311 312 313 314 315 316 317 def __init__ ( self , chan : Broadcast [ T ]) -> None : \"\"\"Create a `Peekable` instance. Args: chan: The broadcast channel this Peekable will try to peek into. \"\"\" self . _chan = chan peek () \u00a4 Return the latest value that was sent to the channel. RETURNS DESCRIPTION Optional [ T ] The latest value received by the channel, and None , if nothing has been sent to the channel yet, or if the channel is closed. Source code in frequenz/channels/broadcast.py 319 320 321 322 323 324 325 326 def peek ( self ) -> Optional [ T ]: \"\"\"Return the latest value that was sent to the channel. Returns: The latest value received by the channel, and `None`, if nothing has been sent to the channel yet, or if the channel is closed. \"\"\" return self . _chan . _latest # pylint: disable=protected-access frequenz.channels.broadcast.Receiver \u00a4 Bases: BufferedReceiver [ T ] A receiver to receive messages from the broadcast channel. Should not be created directly, but through the Broadcast.get_receiver() method. Source code in frequenz/channels/broadcast.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 class Receiver ( BufferedReceiver [ T ]): \"\"\"A receiver to receive messages from the broadcast channel. Should not be created directly, but through the [Broadcast.get_receiver()][frequenz.channels.Broadcast.get_receiver] method. \"\"\" def __init__ ( self , uuid : UUID , name : str , maxsize : int , chan : Broadcast [ T ]) -> None : \"\"\"Create a broadcast receiver. Broadcast receivers have their own buffer, and when messages are not being consumed fast enough and the buffer fills up, old messages will get dropped just in this receiver. Args: uuid: A uuid to identify the receiver in the broadcast channel's list of receivers. name: A name to identify the receiver in the logs. maxsize: Size of the receiver's buffer. chan: a reference to the Broadcast channel that this receiver belongs to. \"\"\" self . _uuid = uuid self . _name = name self . _chan = chan self . _q : Deque [ T ] = deque ( maxlen = maxsize ) self . _active = True def __del__ ( self ) -> None : \"\"\"Drop this receiver from the list of Broadcast receivers.\"\"\" if self . _active : self . _chan . _drop_receiver ( self . _uuid ) def enqueue ( self , msg : T ) -> None : \"\"\"Put a message into this receiver's queue. To be called by broadcast senders. If the receiver's queue is already full, drop the oldest message to make room for the incoming message, and log a warning. Args: msg: The message to be sent. \"\"\" if len ( self . _q ) == self . _q . maxlen : self . _q . popleft () logger . warning ( \"Broadcast receiver [ %s : %s ] is full. Oldest message was dropped.\" , self . _chan . name , self . _name , ) self . _q . append ( msg ) def __len__ ( self ) -> int : \"\"\"Return the number of unconsumed messages in the broadcast receiver. Returns: Number of items in the receiver's internal queue. \"\"\" return len ( self . _q ) async def receive ( self ) -> Optional [ T ]: \"\"\"Receive a message from the Broadcast channel. Waits until there are messages available in the channel and returns them. If there are no remaining messages in the buffer and the channel is closed, returns `None` immediately. If [into_peekable()][frequenz.channels.Receiver.into_peekable] is called on a broadcast `Receiver`, further calls to `receive`, will raise an `EOFError`. Raises: EOFError: when the receiver has been converted into a `Peekable`. Returns: `None`, if the channel is closed, a message otherwise. \"\"\" if not self . _active : raise EOFError ( \"This receiver is no longer active.\" ) while len ( self . _q ) == 0 : if self . _chan . closed : return None async with self . _chan . recv_cv : await self . _chan . recv_cv . wait () ret = self . _q . popleft () return ret def into_peekable ( self ) -> Peekable [ T ]: \"\"\"Convert the `Receiver` implementation into a `Peekable`. Once this function has been called, the receiver will no longer be usable, and calling [receive()][frequenz.channels.Receiver.receive] on the receiver will raise an exception. Returns: A `Peekable` instance. \"\"\" self . _chan . _drop_receiver ( self . _uuid ) # pylint: disable=protected-access self . _active = False return Peekable ( self . _chan ) Functions \u00a4 __del__ () \u00a4 Drop this receiver from the list of Broadcast receivers. Source code in frequenz/channels/broadcast.py 228 229 230 231 def __del__ ( self ) -> None : \"\"\"Drop this receiver from the list of Broadcast receivers.\"\"\" if self . _active : self . _chan . _drop_receiver ( self . _uuid ) __init__ ( uuid , name , maxsize , chan ) \u00a4 Create a broadcast receiver. Broadcast receivers have their own buffer, and when messages are not being consumed fast enough and the buffer fills up, old messages will get dropped just in this receiver. PARAMETER DESCRIPTION uuid A uuid to identify the receiver in the broadcast channel's list of receivers. TYPE: UUID name A name to identify the receiver in the logs. TYPE: str maxsize Size of the receiver's buffer. TYPE: int chan a reference to the Broadcast channel that this receiver belongs to. TYPE: Broadcast [ T ] Source code in frequenz/channels/broadcast.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def __init__ ( self , uuid : UUID , name : str , maxsize : int , chan : Broadcast [ T ]) -> None : \"\"\"Create a broadcast receiver. Broadcast receivers have their own buffer, and when messages are not being consumed fast enough and the buffer fills up, old messages will get dropped just in this receiver. Args: uuid: A uuid to identify the receiver in the broadcast channel's list of receivers. name: A name to identify the receiver in the logs. maxsize: Size of the receiver's buffer. chan: a reference to the Broadcast channel that this receiver belongs to. \"\"\" self . _uuid = uuid self . _name = name self . _chan = chan self . _q : Deque [ T ] = deque ( maxlen = maxsize ) self . _active = True __len__ () \u00a4 Return the number of unconsumed messages in the broadcast receiver. RETURNS DESCRIPTION int Number of items in the receiver's internal queue. Source code in frequenz/channels/broadcast.py 252 253 254 255 256 257 258 def __len__ ( self ) -> int : \"\"\"Return the number of unconsumed messages in the broadcast receiver. Returns: Number of items in the receiver's internal queue. \"\"\" return len ( self . _q ) enqueue ( msg ) \u00a4 Put a message into this receiver's queue. To be called by broadcast senders. If the receiver's queue is already full, drop the oldest message to make room for the incoming message, and log a warning. PARAMETER DESCRIPTION msg The message to be sent. TYPE: T Source code in frequenz/channels/broadcast.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def enqueue ( self , msg : T ) -> None : \"\"\"Put a message into this receiver's queue. To be called by broadcast senders. If the receiver's queue is already full, drop the oldest message to make room for the incoming message, and log a warning. Args: msg: The message to be sent. \"\"\" if len ( self . _q ) == self . _q . maxlen : self . _q . popleft () logger . warning ( \"Broadcast receiver [ %s : %s ] is full. Oldest message was dropped.\" , self . _chan . name , self . _name , ) self . _q . append ( msg ) into_peekable () \u00a4 Convert the Receiver implementation into a Peekable . Once this function has been called, the receiver will no longer be usable, and calling receive() on the receiver will raise an exception. RETURNS DESCRIPTION Peekable [ T ] A Peekable instance. Source code in frequenz/channels/broadcast.py 288 289 290 291 292 293 294 295 296 297 298 299 300 def into_peekable ( self ) -> Peekable [ T ]: \"\"\"Convert the `Receiver` implementation into a `Peekable`. Once this function has been called, the receiver will no longer be usable, and calling [receive()][frequenz.channels.Receiver.receive] on the receiver will raise an exception. Returns: A `Peekable` instance. \"\"\" self . _chan . _drop_receiver ( self . _uuid ) # pylint: disable=protected-access self . _active = False return Peekable ( self . _chan ) receive () async \u00a4 Receive a message from the Broadcast channel. Waits until there are messages available in the channel and returns them. If there are no remaining messages in the buffer and the channel is closed, returns None immediately. If into_peekable() is called on a broadcast Receiver , further calls to receive , will raise an EOFError . RAISES DESCRIPTION EOFError when the receiver has been converted into a Peekable . RETURNS DESCRIPTION Optional [ T ] None , if the channel is closed, a message otherwise. Source code in frequenz/channels/broadcast.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 async def receive ( self ) -> Optional [ T ]: \"\"\"Receive a message from the Broadcast channel. Waits until there are messages available in the channel and returns them. If there are no remaining messages in the buffer and the channel is closed, returns `None` immediately. If [into_peekable()][frequenz.channels.Receiver.into_peekable] is called on a broadcast `Receiver`, further calls to `receive`, will raise an `EOFError`. Raises: EOFError: when the receiver has been converted into a `Peekable`. Returns: `None`, if the channel is closed, a message otherwise. \"\"\" if not self . _active : raise EOFError ( \"This receiver is no longer active.\" ) while len ( self . _q ) == 0 : if self . _chan . closed : return None async with self . _chan . recv_cv : await self . _chan . recv_cv . wait () ret = self . _q . popleft () return ret frequenz.channels.broadcast.Sender \u00a4 Bases: BaseSender [ T ] A sender to send messages to the broadcast channel. Should not be created directly, but through the Broadcast.get_sender() method. Source code in frequenz/channels/broadcast.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 class Sender ( BaseSender [ T ]): \"\"\"A sender to send messages to the broadcast channel. Should not be created directly, but through the [Broadcast.get_sender()][frequenz.channels.Broadcast.get_sender] method. \"\"\" def __init__ ( self , chan : Broadcast [ T ]) -> None : \"\"\"Create a Broadcast sender. Args: chan: A reference to the broadcast channel this sender belongs to. \"\"\" self . _chan = chan async def send ( self , msg : T ) -> bool : \"\"\"Send a message to all broadcast receivers. Args: msg: The message to be broadcast. Returns: Whether the message was sent, based on whether the broadcast channel is open or not. \"\"\" if self . _chan . closed : return False # pylint: disable=protected-access self . _chan . _latest = msg for recv in self . _chan . receivers . values (): recv . enqueue ( msg ) async with self . _chan . recv_cv : self . _chan . recv_cv . notify_all () return True Functions \u00a4 __init__ ( chan ) \u00a4 Create a Broadcast sender. PARAMETER DESCRIPTION chan A reference to the broadcast channel this sender belongs to. TYPE: Broadcast [ T ] Source code in frequenz/channels/broadcast.py 169 170 171 172 173 174 175 def __init__ ( self , chan : Broadcast [ T ]) -> None : \"\"\"Create a Broadcast sender. Args: chan: A reference to the broadcast channel this sender belongs to. \"\"\" self . _chan = chan send ( msg ) async \u00a4 Send a message to all broadcast receivers. PARAMETER DESCRIPTION msg The message to be broadcast. TYPE: T RETURNS DESCRIPTION bool Whether the message was sent, based on whether the broadcast channel is open or not. Source code in frequenz/channels/broadcast.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 async def send ( self , msg : T ) -> bool : \"\"\"Send a message to all broadcast receivers. Args: msg: The message to be broadcast. Returns: Whether the message was sent, based on whether the broadcast channel is open or not. \"\"\" if self . _chan . closed : return False # pylint: disable=protected-access self . _chan . _latest = msg for recv in self . _chan . receivers . values (): recv . enqueue ( msg ) async with self . _chan . recv_cv : self . _chan . recv_cv . notify_all () return True","title":"broadcast"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast","text":"A channel to broadcast messages to all receivers.","title":"broadcast"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast-classes","text":"","title":"Classes"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Broadcast","text":"Bases: Generic [ T ] A channel to broadcast messages to multiple receivers. Broadcast channels can have multiple senders and multiple receivers. Each message sent through any of the senders is received by all of the receivers. Internally, a broadcast receiver's buffer is implemented with just append/pop operations on either side of a deque , which are thread-safe. Because of this, Broadcast channels are thread-safe. When there are multiple channel receivers, they can be awaited simultaneously using Select , Merge or MergeNamed . Example async def send ( sender : channel . Sender ) -> None : while True : next = random . randint ( 3 , 17 ) print ( f \"sending: { next } \" ) await sender . send ( next ) async def recv ( id : int , receiver : channel . Receiver ) -> None : while True : next = await receiver . receive () print ( f \"receiver_ { id } received { next } \" ) await asyncio . sleep ( 0.1 ) # sleep (or work) with the data bcast = channel . Broadcast () sender = bcast . get_sender () receiver_1 = bcast . get_receiver () asyncio . create_task ( send ( sender )) await recv ( 1 , receiver_1 ) Check the tests and benchmarks directories for more examples. Source code in frequenz/channels/broadcast.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class Broadcast ( Generic [ T ]): \"\"\"A channel to broadcast messages to multiple receivers. `Broadcast` channels can have multiple senders and multiple receivers. Each message sent through any of the senders is received by all of the receivers. Internally, a broadcast receiver's buffer is implemented with just append/pop operations on either side of a [deque][collections.deque], which are thread-safe. Because of this, `Broadcast` channels are thread-safe. When there are multiple channel receivers, they can be awaited simultaneously using [Select][frequenz.channels.Select], [Merge][frequenz.channels.Merge] or [MergeNamed][frequenz.channels.MergeNamed]. Example: ``` python async def send(sender: channel.Sender) -> None: while True: next = random.randint(3, 17) print(f\"sending: {next}\") await sender.send(next) async def recv(id: int, receiver: channel.Receiver) -> None: while True: next = await receiver.receive() print(f\"receiver_{id} received {next}\") await asyncio.sleep(0.1) # sleep (or work) with the data bcast = channel.Broadcast() sender = bcast.get_sender() receiver_1 = bcast.get_receiver() asyncio.create_task(send(sender)) await recv(1, receiver_1) ``` Check the `tests` and `benchmarks` directories for more examples. \"\"\" def __init__ ( self , name : str , resend_latest : bool = False ) -> None : \"\"\"Create a Broadcast channel. Args: name: A name for the broadcast channel, typically based on the type of data sent through it. Used to identify the channel in the logs. resend_latest: When True, every time a new receiver is created with `get_receiver`, it will automatically get sent the latest value on the channel. This allows new receivers on slow streams to get the latest value as soon as they are created, without having to wait for the next message on the channel to arrive. \"\"\" self . name : str = name self . _resend_latest = resend_latest self . recv_cv : Condition = Condition () self . receivers : Dict [ UUID , Receiver [ T ]] = {} self . closed : bool = False self . _latest : Optional [ T ] = None async def close ( self ) -> None : \"\"\"Close the Broadcast channel. Any further attempts to [send()][frequenz.channels.Sender.send] data will return `False`. Receivers will still be able to drain the pending items on their queues, but after that, subsequent [receive()][frequenz.channels.Receiver.receive] calls will return `None` immediately. \"\"\" self . _latest = None self . closed = True async with self . recv_cv : self . recv_cv . notify_all () def _drop_receiver ( self , uuid : UUID ) -> None : \"\"\"Drop a specific receiver from the list of broadcast receivers. Called from the destructors of receivers. Args: uuid: a uuid identifying the receiver to be dropped. \"\"\" if uuid in self . receivers : del self . receivers [ uuid ] def get_sender ( self ) -> Sender [ T ]: \"\"\"Create a new broadcast sender. Returns: A Sender instance attached to the broadcast channel. \"\"\" return Sender ( self ) def get_receiver ( self , name : Optional [ str ] = None , maxsize : int = 50 ) -> Receiver [ T ]: \"\"\"Create a new broadcast receiver. Broadcast receivers have their own buffer, and when messages are not being consumed fast enough and the buffer fills up, old messages will get dropped just in this receiver. Args: name: A name to identify the receiver in the logs. maxsize: Size of the receiver's buffer. Returns: A Receiver instance attached to the broadcast channel. \"\"\" uuid = uuid4 () if name is None : name = str ( uuid ) recv : Receiver [ T ] = Receiver ( uuid , name , maxsize , self ) self . receivers [ uuid ] = recv if self . _resend_latest and self . _latest is not None : recv . enqueue ( self . _latest ) return recv def get_peekable ( self ) -> Peekable [ T ]: \"\"\"Create a new Peekable for the broadcast channel. A Peekable provides a [peek()][frequenz.channels.Peekable.peek] method that allows the user to get a peek at the latest value in the channel, without consuming anything. Returns: A Peekable to peek into the broadcast channel with. \"\"\" return Peekable ( self )","title":"Broadcast"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Broadcast-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Broadcast.__init__","text":"Create a Broadcast channel. PARAMETER DESCRIPTION name A name for the broadcast channel, typically based on the type of data sent through it. Used to identify the channel in the logs. TYPE: str resend_latest When True, every time a new receiver is created with get_receiver , it will automatically get sent the latest value on the channel. This allows new receivers on slow streams to get the latest value as soon as they are created, without having to wait for the next message on the channel to arrive. TYPE: bool DEFAULT: False Source code in frequenz/channels/broadcast.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def __init__ ( self , name : str , resend_latest : bool = False ) -> None : \"\"\"Create a Broadcast channel. Args: name: A name for the broadcast channel, typically based on the type of data sent through it. Used to identify the channel in the logs. resend_latest: When True, every time a new receiver is created with `get_receiver`, it will automatically get sent the latest value on the channel. This allows new receivers on slow streams to get the latest value as soon as they are created, without having to wait for the next message on the channel to arrive. \"\"\" self . name : str = name self . _resend_latest = resend_latest self . recv_cv : Condition = Condition () self . receivers : Dict [ UUID , Receiver [ T ]] = {} self . closed : bool = False self . _latest : Optional [ T ] = None","title":"__init__()"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Broadcast.close","text":"Close the Broadcast channel. Any further attempts to send() data will return False . Receivers will still be able to drain the pending items on their queues, but after that, subsequent receive() calls will return None immediately. Source code in frequenz/channels/broadcast.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 async def close ( self ) -> None : \"\"\"Close the Broadcast channel. Any further attempts to [send()][frequenz.channels.Sender.send] data will return `False`. Receivers will still be able to drain the pending items on their queues, but after that, subsequent [receive()][frequenz.channels.Receiver.receive] calls will return `None` immediately. \"\"\" self . _latest = None self . closed = True async with self . recv_cv : self . recv_cv . notify_all ()","title":"close()"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Broadcast.get_peekable","text":"Create a new Peekable for the broadcast channel. A Peekable provides a peek() method that allows the user to get a peek at the latest value in the channel, without consuming anything. RETURNS DESCRIPTION Peekable [ T ] A Peekable to peek into the broadcast channel with. Source code in frequenz/channels/broadcast.py 148 149 150 151 152 153 154 155 156 157 158 def get_peekable ( self ) -> Peekable [ T ]: \"\"\"Create a new Peekable for the broadcast channel. A Peekable provides a [peek()][frequenz.channels.Peekable.peek] method that allows the user to get a peek at the latest value in the channel, without consuming anything. Returns: A Peekable to peek into the broadcast channel with. \"\"\" return Peekable ( self )","title":"get_peekable()"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Broadcast.get_receiver","text":"Create a new broadcast receiver. Broadcast receivers have their own buffer, and when messages are not being consumed fast enough and the buffer fills up, old messages will get dropped just in this receiver. PARAMETER DESCRIPTION name A name to identify the receiver in the logs. TYPE: Optional [ str ] DEFAULT: None maxsize Size of the receiver's buffer. TYPE: int DEFAULT: 50 RETURNS DESCRIPTION Receiver [ T ] A Receiver instance attached to the broadcast channel. Source code in frequenz/channels/broadcast.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def get_receiver ( self , name : Optional [ str ] = None , maxsize : int = 50 ) -> Receiver [ T ]: \"\"\"Create a new broadcast receiver. Broadcast receivers have their own buffer, and when messages are not being consumed fast enough and the buffer fills up, old messages will get dropped just in this receiver. Args: name: A name to identify the receiver in the logs. maxsize: Size of the receiver's buffer. Returns: A Receiver instance attached to the broadcast channel. \"\"\" uuid = uuid4 () if name is None : name = str ( uuid ) recv : Receiver [ T ] = Receiver ( uuid , name , maxsize , self ) self . receivers [ uuid ] = recv if self . _resend_latest and self . _latest is not None : recv . enqueue ( self . _latest ) return recv","title":"get_receiver()"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Broadcast.get_sender","text":"Create a new broadcast sender. RETURNS DESCRIPTION Sender [ T ] A Sender instance attached to the broadcast channel. Source code in frequenz/channels/broadcast.py 115 116 117 118 119 120 121 def get_sender ( self ) -> Sender [ T ]: \"\"\"Create a new broadcast sender. Returns: A Sender instance attached to the broadcast channel. \"\"\" return Sender ( self )","title":"get_sender()"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Peekable","text":"Bases: BasePeekable [ T ] A Peekable to peek into broadcast channels. A Peekable provides a peek() method that allows the user to get a peek at the latest value in the channel, without consuming anything. Source code in frequenz/channels/broadcast.py 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 class Peekable ( BasePeekable [ T ]): \"\"\"A Peekable to peek into broadcast channels. A Peekable provides a [peek()][frequenz.channels.Peekable] method that allows the user to get a peek at the latest value in the channel, without consuming anything. \"\"\" def __init__ ( self , chan : Broadcast [ T ]) -> None : \"\"\"Create a `Peekable` instance. Args: chan: The broadcast channel this Peekable will try to peek into. \"\"\" self . _chan = chan def peek ( self ) -> Optional [ T ]: \"\"\"Return the latest value that was sent to the channel. Returns: The latest value received by the channel, and `None`, if nothing has been sent to the channel yet, or if the channel is closed. \"\"\" return self . _chan . _latest # pylint: disable=protected-access","title":"Peekable"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Peekable-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Peekable.__init__","text":"Create a Peekable instance. PARAMETER DESCRIPTION chan The broadcast channel this Peekable will try to peek into. TYPE: Broadcast [ T ] Source code in frequenz/channels/broadcast.py 311 312 313 314 315 316 317 def __init__ ( self , chan : Broadcast [ T ]) -> None : \"\"\"Create a `Peekable` instance. Args: chan: The broadcast channel this Peekable will try to peek into. \"\"\" self . _chan = chan","title":"__init__()"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Peekable.peek","text":"Return the latest value that was sent to the channel. RETURNS DESCRIPTION Optional [ T ] The latest value received by the channel, and None , if nothing has been sent to the channel yet, or if the channel is closed. Source code in frequenz/channels/broadcast.py 319 320 321 322 323 324 325 326 def peek ( self ) -> Optional [ T ]: \"\"\"Return the latest value that was sent to the channel. Returns: The latest value received by the channel, and `None`, if nothing has been sent to the channel yet, or if the channel is closed. \"\"\" return self . _chan . _latest # pylint: disable=protected-access","title":"peek()"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Receiver","text":"Bases: BufferedReceiver [ T ] A receiver to receive messages from the broadcast channel. Should not be created directly, but through the Broadcast.get_receiver() method. Source code in frequenz/channels/broadcast.py 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 class Receiver ( BufferedReceiver [ T ]): \"\"\"A receiver to receive messages from the broadcast channel. Should not be created directly, but through the [Broadcast.get_receiver()][frequenz.channels.Broadcast.get_receiver] method. \"\"\" def __init__ ( self , uuid : UUID , name : str , maxsize : int , chan : Broadcast [ T ]) -> None : \"\"\"Create a broadcast receiver. Broadcast receivers have their own buffer, and when messages are not being consumed fast enough and the buffer fills up, old messages will get dropped just in this receiver. Args: uuid: A uuid to identify the receiver in the broadcast channel's list of receivers. name: A name to identify the receiver in the logs. maxsize: Size of the receiver's buffer. chan: a reference to the Broadcast channel that this receiver belongs to. \"\"\" self . _uuid = uuid self . _name = name self . _chan = chan self . _q : Deque [ T ] = deque ( maxlen = maxsize ) self . _active = True def __del__ ( self ) -> None : \"\"\"Drop this receiver from the list of Broadcast receivers.\"\"\" if self . _active : self . _chan . _drop_receiver ( self . _uuid ) def enqueue ( self , msg : T ) -> None : \"\"\"Put a message into this receiver's queue. To be called by broadcast senders. If the receiver's queue is already full, drop the oldest message to make room for the incoming message, and log a warning. Args: msg: The message to be sent. \"\"\" if len ( self . _q ) == self . _q . maxlen : self . _q . popleft () logger . warning ( \"Broadcast receiver [ %s : %s ] is full. Oldest message was dropped.\" , self . _chan . name , self . _name , ) self . _q . append ( msg ) def __len__ ( self ) -> int : \"\"\"Return the number of unconsumed messages in the broadcast receiver. Returns: Number of items in the receiver's internal queue. \"\"\" return len ( self . _q ) async def receive ( self ) -> Optional [ T ]: \"\"\"Receive a message from the Broadcast channel. Waits until there are messages available in the channel and returns them. If there are no remaining messages in the buffer and the channel is closed, returns `None` immediately. If [into_peekable()][frequenz.channels.Receiver.into_peekable] is called on a broadcast `Receiver`, further calls to `receive`, will raise an `EOFError`. Raises: EOFError: when the receiver has been converted into a `Peekable`. Returns: `None`, if the channel is closed, a message otherwise. \"\"\" if not self . _active : raise EOFError ( \"This receiver is no longer active.\" ) while len ( self . _q ) == 0 : if self . _chan . closed : return None async with self . _chan . recv_cv : await self . _chan . recv_cv . wait () ret = self . _q . popleft () return ret def into_peekable ( self ) -> Peekable [ T ]: \"\"\"Convert the `Receiver` implementation into a `Peekable`. Once this function has been called, the receiver will no longer be usable, and calling [receive()][frequenz.channels.Receiver.receive] on the receiver will raise an exception. Returns: A `Peekable` instance. \"\"\" self . _chan . _drop_receiver ( self . _uuid ) # pylint: disable=protected-access self . _active = False return Peekable ( self . _chan )","title":"Receiver"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Receiver-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Receiver.__del__","text":"Drop this receiver from the list of Broadcast receivers. Source code in frequenz/channels/broadcast.py 228 229 230 231 def __del__ ( self ) -> None : \"\"\"Drop this receiver from the list of Broadcast receivers.\"\"\" if self . _active : self . _chan . _drop_receiver ( self . _uuid )","title":"__del__()"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Receiver.__init__","text":"Create a broadcast receiver. Broadcast receivers have their own buffer, and when messages are not being consumed fast enough and the buffer fills up, old messages will get dropped just in this receiver. PARAMETER DESCRIPTION uuid A uuid to identify the receiver in the broadcast channel's list of receivers. TYPE: UUID name A name to identify the receiver in the logs. TYPE: str maxsize Size of the receiver's buffer. TYPE: int chan a reference to the Broadcast channel that this receiver belongs to. TYPE: Broadcast [ T ] Source code in frequenz/channels/broadcast.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def __init__ ( self , uuid : UUID , name : str , maxsize : int , chan : Broadcast [ T ]) -> None : \"\"\"Create a broadcast receiver. Broadcast receivers have their own buffer, and when messages are not being consumed fast enough and the buffer fills up, old messages will get dropped just in this receiver. Args: uuid: A uuid to identify the receiver in the broadcast channel's list of receivers. name: A name to identify the receiver in the logs. maxsize: Size of the receiver's buffer. chan: a reference to the Broadcast channel that this receiver belongs to. \"\"\" self . _uuid = uuid self . _name = name self . _chan = chan self . _q : Deque [ T ] = deque ( maxlen = maxsize ) self . _active = True","title":"__init__()"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Receiver.__len__","text":"Return the number of unconsumed messages in the broadcast receiver. RETURNS DESCRIPTION int Number of items in the receiver's internal queue. Source code in frequenz/channels/broadcast.py 252 253 254 255 256 257 258 def __len__ ( self ) -> int : \"\"\"Return the number of unconsumed messages in the broadcast receiver. Returns: Number of items in the receiver's internal queue. \"\"\" return len ( self . _q )","title":"__len__()"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Receiver.enqueue","text":"Put a message into this receiver's queue. To be called by broadcast senders. If the receiver's queue is already full, drop the oldest message to make room for the incoming message, and log a warning. PARAMETER DESCRIPTION msg The message to be sent. TYPE: T Source code in frequenz/channels/broadcast.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def enqueue ( self , msg : T ) -> None : \"\"\"Put a message into this receiver's queue. To be called by broadcast senders. If the receiver's queue is already full, drop the oldest message to make room for the incoming message, and log a warning. Args: msg: The message to be sent. \"\"\" if len ( self . _q ) == self . _q . maxlen : self . _q . popleft () logger . warning ( \"Broadcast receiver [ %s : %s ] is full. Oldest message was dropped.\" , self . _chan . name , self . _name , ) self . _q . append ( msg )","title":"enqueue()"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Receiver.into_peekable","text":"Convert the Receiver implementation into a Peekable . Once this function has been called, the receiver will no longer be usable, and calling receive() on the receiver will raise an exception. RETURNS DESCRIPTION Peekable [ T ] A Peekable instance. Source code in frequenz/channels/broadcast.py 288 289 290 291 292 293 294 295 296 297 298 299 300 def into_peekable ( self ) -> Peekable [ T ]: \"\"\"Convert the `Receiver` implementation into a `Peekable`. Once this function has been called, the receiver will no longer be usable, and calling [receive()][frequenz.channels.Receiver.receive] on the receiver will raise an exception. Returns: A `Peekable` instance. \"\"\" self . _chan . _drop_receiver ( self . _uuid ) # pylint: disable=protected-access self . _active = False return Peekable ( self . _chan )","title":"into_peekable()"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Receiver.receive","text":"Receive a message from the Broadcast channel. Waits until there are messages available in the channel and returns them. If there are no remaining messages in the buffer and the channel is closed, returns None immediately. If into_peekable() is called on a broadcast Receiver , further calls to receive , will raise an EOFError . RAISES DESCRIPTION EOFError when the receiver has been converted into a Peekable . RETURNS DESCRIPTION Optional [ T ] None , if the channel is closed, a message otherwise. Source code in frequenz/channels/broadcast.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 async def receive ( self ) -> Optional [ T ]: \"\"\"Receive a message from the Broadcast channel. Waits until there are messages available in the channel and returns them. If there are no remaining messages in the buffer and the channel is closed, returns `None` immediately. If [into_peekable()][frequenz.channels.Receiver.into_peekable] is called on a broadcast `Receiver`, further calls to `receive`, will raise an `EOFError`. Raises: EOFError: when the receiver has been converted into a `Peekable`. Returns: `None`, if the channel is closed, a message otherwise. \"\"\" if not self . _active : raise EOFError ( \"This receiver is no longer active.\" ) while len ( self . _q ) == 0 : if self . _chan . closed : return None async with self . _chan . recv_cv : await self . _chan . recv_cv . wait () ret = self . _q . popleft () return ret","title":"receive()"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Sender","text":"Bases: BaseSender [ T ] A sender to send messages to the broadcast channel. Should not be created directly, but through the Broadcast.get_sender() method. Source code in frequenz/channels/broadcast.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 class Sender ( BaseSender [ T ]): \"\"\"A sender to send messages to the broadcast channel. Should not be created directly, but through the [Broadcast.get_sender()][frequenz.channels.Broadcast.get_sender] method. \"\"\" def __init__ ( self , chan : Broadcast [ T ]) -> None : \"\"\"Create a Broadcast sender. Args: chan: A reference to the broadcast channel this sender belongs to. \"\"\" self . _chan = chan async def send ( self , msg : T ) -> bool : \"\"\"Send a message to all broadcast receivers. Args: msg: The message to be broadcast. Returns: Whether the message was sent, based on whether the broadcast channel is open or not. \"\"\" if self . _chan . closed : return False # pylint: disable=protected-access self . _chan . _latest = msg for recv in self . _chan . receivers . values (): recv . enqueue ( msg ) async with self . _chan . recv_cv : self . _chan . recv_cv . notify_all () return True","title":"Sender"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Sender-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Sender.__init__","text":"Create a Broadcast sender. PARAMETER DESCRIPTION chan A reference to the broadcast channel this sender belongs to. TYPE: Broadcast [ T ] Source code in frequenz/channels/broadcast.py 169 170 171 172 173 174 175 def __init__ ( self , chan : Broadcast [ T ]) -> None : \"\"\"Create a Broadcast sender. Args: chan: A reference to the broadcast channel this sender belongs to. \"\"\" self . _chan = chan","title":"__init__()"},{"location":"reference/frequenz/channels/broadcast/#frequenz.channels.broadcast.Sender.send","text":"Send a message to all broadcast receivers. PARAMETER DESCRIPTION msg The message to be broadcast. TYPE: T RETURNS DESCRIPTION bool Whether the message was sent, based on whether the broadcast channel is open or not. Source code in frequenz/channels/broadcast.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 async def send ( self , msg : T ) -> bool : \"\"\"Send a message to all broadcast receivers. Args: msg: The message to be broadcast. Returns: Whether the message was sent, based on whether the broadcast channel is open or not. \"\"\" if self . _chan . closed : return False # pylint: disable=protected-access self . _chan . _latest = msg for recv in self . _chan . receivers . values (): recv . enqueue ( msg ) async with self . _chan . recv_cv : self . _chan . recv_cv . notify_all () return True","title":"send()"},{"location":"reference/frequenz/channels/merge/","text":"frequenz.channels.merge \u00a4 Merge messages coming from channels into a single stream. Classes \u00a4 frequenz.channels.merge.Merge \u00a4 Bases: Receiver [ T ] Merge messages coming from multiple channels into a single stream. Example For example, if there are two channel receivers with the same type, they can be awaited together, and their results merged into a single stream, by using Merge like this: merge = Merge ( receiver1 , receiver2 ) while msg := await merge . receive (): # do something with msg pass Source code in frequenz/channels/merge.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class Merge ( Receiver [ T ]): \"\"\"Merge messages coming from multiple channels into a single stream. Example: For example, if there are two channel receivers with the same type, they can be awaited together, and their results merged into a single stream, by using `Merge` like this: ```python merge = Merge(receiver1, receiver2) while msg := await merge.receive(): # do something with msg pass ``` \"\"\" def __init__ ( self , * args : Receiver [ T ]) -> None : \"\"\"Create a `Merge` instance. Args: *args: sequence of channel receivers. \"\"\" self . _receivers = { str ( id ): recv for id , recv in enumerate ( args )} self . _pending : Set [ asyncio . Task [ Any ]] = { asyncio . create_task ( recv . receive (), name = name ) for name , recv in self . _receivers . items () } self . _results : Deque [ T ] = deque ( maxlen = len ( self . _receivers )) def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel () async def receive ( self ) -> Optional [ T ]: \"\"\"Wait until there's a message in any of the channels. Returns: The next message that was received, or `None`, if all channels have closed. \"\"\" # we use a while loop to continue to wait for new data, in case the # previous `wait` completed because a channel was closed. while True : if len ( self . _results ) > 0 : return self . _results . popleft () if len ( self . _pending ) == 0 : return None done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () result = item . result () # if channel is closed, don't add a task for it again. if result is None : continue self . _results . append ( result ) self . _pending . add ( asyncio . create_task ( self . _receivers [ name ] . receive (), name = name ) ) Functions \u00a4 __del__ () \u00a4 Cleanup any pending tasks. Source code in frequenz/channels/merge.py 42 43 44 45 def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel () __init__ ( * args ) \u00a4 Create a Merge instance. PARAMETER DESCRIPTION *args sequence of channel receivers. TYPE: Receiver [ T ] DEFAULT: () Source code in frequenz/channels/merge.py 29 30 31 32 33 34 35 36 37 38 39 40 def __init__ ( self , * args : Receiver [ T ]) -> None : \"\"\"Create a `Merge` instance. Args: *args: sequence of channel receivers. \"\"\" self . _receivers = { str ( id ): recv for id , recv in enumerate ( args )} self . _pending : Set [ asyncio . Task [ Any ]] = { asyncio . create_task ( recv . receive (), name = name ) for name , recv in self . _receivers . items () } self . _results : Deque [ T ] = deque ( maxlen = len ( self . _receivers )) receive () async \u00a4 Wait until there's a message in any of the channels. RETURNS DESCRIPTION Optional [ T ] The next message that was received, or None , if all channels have closed. Source code in frequenz/channels/merge.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 async def receive ( self ) -> Optional [ T ]: \"\"\"Wait until there's a message in any of the channels. Returns: The next message that was received, or `None`, if all channels have closed. \"\"\" # we use a while loop to continue to wait for new data, in case the # previous `wait` completed because a channel was closed. while True : if len ( self . _results ) > 0 : return self . _results . popleft () if len ( self . _pending ) == 0 : return None done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () result = item . result () # if channel is closed, don't add a task for it again. if result is None : continue self . _results . append ( result ) self . _pending . add ( asyncio . create_task ( self . _receivers [ name ] . receive (), name = name ) )","title":"merge"},{"location":"reference/frequenz/channels/merge/#frequenz.channels.merge","text":"Merge messages coming from channels into a single stream.","title":"merge"},{"location":"reference/frequenz/channels/merge/#frequenz.channels.merge-classes","text":"","title":"Classes"},{"location":"reference/frequenz/channels/merge/#frequenz.channels.merge.Merge","text":"Bases: Receiver [ T ] Merge messages coming from multiple channels into a single stream. Example For example, if there are two channel receivers with the same type, they can be awaited together, and their results merged into a single stream, by using Merge like this: merge = Merge ( receiver1 , receiver2 ) while msg := await merge . receive (): # do something with msg pass Source code in frequenz/channels/merge.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class Merge ( Receiver [ T ]): \"\"\"Merge messages coming from multiple channels into a single stream. Example: For example, if there are two channel receivers with the same type, they can be awaited together, and their results merged into a single stream, by using `Merge` like this: ```python merge = Merge(receiver1, receiver2) while msg := await merge.receive(): # do something with msg pass ``` \"\"\" def __init__ ( self , * args : Receiver [ T ]) -> None : \"\"\"Create a `Merge` instance. Args: *args: sequence of channel receivers. \"\"\" self . _receivers = { str ( id ): recv for id , recv in enumerate ( args )} self . _pending : Set [ asyncio . Task [ Any ]] = { asyncio . create_task ( recv . receive (), name = name ) for name , recv in self . _receivers . items () } self . _results : Deque [ T ] = deque ( maxlen = len ( self . _receivers )) def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel () async def receive ( self ) -> Optional [ T ]: \"\"\"Wait until there's a message in any of the channels. Returns: The next message that was received, or `None`, if all channels have closed. \"\"\" # we use a while loop to continue to wait for new data, in case the # previous `wait` completed because a channel was closed. while True : if len ( self . _results ) > 0 : return self . _results . popleft () if len ( self . _pending ) == 0 : return None done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () result = item . result () # if channel is closed, don't add a task for it again. if result is None : continue self . _results . append ( result ) self . _pending . add ( asyncio . create_task ( self . _receivers [ name ] . receive (), name = name ) )","title":"Merge"},{"location":"reference/frequenz/channels/merge/#frequenz.channels.merge.Merge-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/merge/#frequenz.channels.merge.Merge.__del__","text":"Cleanup any pending tasks. Source code in frequenz/channels/merge.py 42 43 44 45 def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel ()","title":"__del__()"},{"location":"reference/frequenz/channels/merge/#frequenz.channels.merge.Merge.__init__","text":"Create a Merge instance. PARAMETER DESCRIPTION *args sequence of channel receivers. TYPE: Receiver [ T ] DEFAULT: () Source code in frequenz/channels/merge.py 29 30 31 32 33 34 35 36 37 38 39 40 def __init__ ( self , * args : Receiver [ T ]) -> None : \"\"\"Create a `Merge` instance. Args: *args: sequence of channel receivers. \"\"\" self . _receivers = { str ( id ): recv for id , recv in enumerate ( args )} self . _pending : Set [ asyncio . Task [ Any ]] = { asyncio . create_task ( recv . receive (), name = name ) for name , recv in self . _receivers . items () } self . _results : Deque [ T ] = deque ( maxlen = len ( self . _receivers ))","title":"__init__()"},{"location":"reference/frequenz/channels/merge/#frequenz.channels.merge.Merge.receive","text":"Wait until there's a message in any of the channels. RETURNS DESCRIPTION Optional [ T ] The next message that was received, or None , if all channels have closed. Source code in frequenz/channels/merge.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 async def receive ( self ) -> Optional [ T ]: \"\"\"Wait until there's a message in any of the channels. Returns: The next message that was received, or `None`, if all channels have closed. \"\"\" # we use a while loop to continue to wait for new data, in case the # previous `wait` completed because a channel was closed. while True : if len ( self . _results ) > 0 : return self . _results . popleft () if len ( self . _pending ) == 0 : return None done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () result = item . result () # if channel is closed, don't add a task for it again. if result is None : continue self . _results . append ( result ) self . _pending . add ( asyncio . create_task ( self . _receivers [ name ] . receive (), name = name ) )","title":"receive()"},{"location":"reference/frequenz/channels/merge_named/","text":"frequenz.channels.merge_named \u00a4 Merge messages coming from channels into a single stream containing name of message. Classes \u00a4 frequenz.channels.merge_named.MergeNamed \u00a4 Bases: Receiver [ Tuple [ str , T ]] Merge messages coming from multiple named channels into a single stream. Source code in frequenz/channels/merge_named.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class MergeNamed ( Receiver [ Tuple [ str , T ]]): \"\"\"Merge messages coming from multiple named channels into a single stream.\"\"\" def __init__ ( self , ** kwargs : Receiver [ T ]) -> None : \"\"\"Create a `MergeNamed` instance. Args: **kwargs: sequence of channel receivers. \"\"\" self . _receivers = kwargs self . _pending : Set [ asyncio . Task [ Any ]] = { asyncio . create_task ( recv . receive (), name = name ) for name , recv in self . _receivers . items () } self . _results : Deque [ Tuple [ str , T ]] = deque ( maxlen = len ( self . _receivers )) def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel () async def receive ( self ) -> Optional [ Tuple [ str , T ]]: \"\"\"Wait until there's a message in any of the channels. Returns: The next message that was received, or `None`, if all channels have closed. \"\"\" # we use a while loop to continue to wait for new data, in case the # previous `wait` completed because a channel was closed. while True : if len ( self . _results ) > 0 : return self . _results . popleft () if len ( self . _pending ) == 0 : return None done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () result = item . result () # if channel is closed, don't add a task for it again. if result is None : continue self . _results . append (( name , result )) self . _pending . add ( asyncio . create_task ( self . _receivers [ name ] . receive (), name = name ) ) Functions \u00a4 __del__ () \u00a4 Cleanup any pending tasks. Source code in frequenz/channels/merge_named.py 29 30 31 32 def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel () __init__ ( ** kwargs ) \u00a4 Create a MergeNamed instance. PARAMETER DESCRIPTION **kwargs sequence of channel receivers. TYPE: Receiver [ T ] DEFAULT: {} Source code in frequenz/channels/merge_named.py 16 17 18 19 20 21 22 23 24 25 26 27 def __init__ ( self , ** kwargs : Receiver [ T ]) -> None : \"\"\"Create a `MergeNamed` instance. Args: **kwargs: sequence of channel receivers. \"\"\" self . _receivers = kwargs self . _pending : Set [ asyncio . Task [ Any ]] = { asyncio . create_task ( recv . receive (), name = name ) for name , recv in self . _receivers . items () } self . _results : Deque [ Tuple [ str , T ]] = deque ( maxlen = len ( self . _receivers )) receive () async \u00a4 Wait until there's a message in any of the channels. RETURNS DESCRIPTION Optional [ Tuple [ str , T ]] The next message that was received, or None , if all channels have closed. Source code in frequenz/channels/merge_named.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 async def receive ( self ) -> Optional [ Tuple [ str , T ]]: \"\"\"Wait until there's a message in any of the channels. Returns: The next message that was received, or `None`, if all channels have closed. \"\"\" # we use a while loop to continue to wait for new data, in case the # previous `wait` completed because a channel was closed. while True : if len ( self . _results ) > 0 : return self . _results . popleft () if len ( self . _pending ) == 0 : return None done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () result = item . result () # if channel is closed, don't add a task for it again. if result is None : continue self . _results . append (( name , result )) self . _pending . add ( asyncio . create_task ( self . _receivers [ name ] . receive (), name = name ) )","title":"merge_named"},{"location":"reference/frequenz/channels/merge_named/#frequenz.channels.merge_named","text":"Merge messages coming from channels into a single stream containing name of message.","title":"merge_named"},{"location":"reference/frequenz/channels/merge_named/#frequenz.channels.merge_named-classes","text":"","title":"Classes"},{"location":"reference/frequenz/channels/merge_named/#frequenz.channels.merge_named.MergeNamed","text":"Bases: Receiver [ Tuple [ str , T ]] Merge messages coming from multiple named channels into a single stream. Source code in frequenz/channels/merge_named.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class MergeNamed ( Receiver [ Tuple [ str , T ]]): \"\"\"Merge messages coming from multiple named channels into a single stream.\"\"\" def __init__ ( self , ** kwargs : Receiver [ T ]) -> None : \"\"\"Create a `MergeNamed` instance. Args: **kwargs: sequence of channel receivers. \"\"\" self . _receivers = kwargs self . _pending : Set [ asyncio . Task [ Any ]] = { asyncio . create_task ( recv . receive (), name = name ) for name , recv in self . _receivers . items () } self . _results : Deque [ Tuple [ str , T ]] = deque ( maxlen = len ( self . _receivers )) def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel () async def receive ( self ) -> Optional [ Tuple [ str , T ]]: \"\"\"Wait until there's a message in any of the channels. Returns: The next message that was received, or `None`, if all channels have closed. \"\"\" # we use a while loop to continue to wait for new data, in case the # previous `wait` completed because a channel was closed. while True : if len ( self . _results ) > 0 : return self . _results . popleft () if len ( self . _pending ) == 0 : return None done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () result = item . result () # if channel is closed, don't add a task for it again. if result is None : continue self . _results . append (( name , result )) self . _pending . add ( asyncio . create_task ( self . _receivers [ name ] . receive (), name = name ) )","title":"MergeNamed"},{"location":"reference/frequenz/channels/merge_named/#frequenz.channels.merge_named.MergeNamed-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/merge_named/#frequenz.channels.merge_named.MergeNamed.__del__","text":"Cleanup any pending tasks. Source code in frequenz/channels/merge_named.py 29 30 31 32 def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel ()","title":"__del__()"},{"location":"reference/frequenz/channels/merge_named/#frequenz.channels.merge_named.MergeNamed.__init__","text":"Create a MergeNamed instance. PARAMETER DESCRIPTION **kwargs sequence of channel receivers. TYPE: Receiver [ T ] DEFAULT: {} Source code in frequenz/channels/merge_named.py 16 17 18 19 20 21 22 23 24 25 26 27 def __init__ ( self , ** kwargs : Receiver [ T ]) -> None : \"\"\"Create a `MergeNamed` instance. Args: **kwargs: sequence of channel receivers. \"\"\" self . _receivers = kwargs self . _pending : Set [ asyncio . Task [ Any ]] = { asyncio . create_task ( recv . receive (), name = name ) for name , recv in self . _receivers . items () } self . _results : Deque [ Tuple [ str , T ]] = deque ( maxlen = len ( self . _receivers ))","title":"__init__()"},{"location":"reference/frequenz/channels/merge_named/#frequenz.channels.merge_named.MergeNamed.receive","text":"Wait until there's a message in any of the channels. RETURNS DESCRIPTION Optional [ Tuple [ str , T ]] The next message that was received, or None , if all channels have closed. Source code in frequenz/channels/merge_named.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 async def receive ( self ) -> Optional [ Tuple [ str , T ]]: \"\"\"Wait until there's a message in any of the channels. Returns: The next message that was received, or `None`, if all channels have closed. \"\"\" # we use a while loop to continue to wait for new data, in case the # previous `wait` completed because a channel was closed. while True : if len ( self . _results ) > 0 : return self . _results . popleft () if len ( self . _pending ) == 0 : return None done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () result = item . result () # if channel is closed, don't add a task for it again. if result is None : continue self . _results . append (( name , result )) self . _pending . add ( asyncio . create_task ( self . _receivers [ name ] . receive (), name = name ) )","title":"receive()"},{"location":"reference/frequenz/channels/select/","text":"frequenz.channels.select \u00a4 Select the first among multiple AsyncIterators. Expects AsyncIterator class to raise StopAsyncIteration exception once no more messages are expected or the channel is closed in case of Receiver class. Classes \u00a4 frequenz.channels.select.Select \u00a4 Select the next available message from a group of AsyncIterators. If Select was created with more AsyncIterator than what are read in the if-chain after each call to ready() , messages coming in the additional async iterators are dropped, and a warning message is logged. Receiver s also function as AsyncIterator . Example For example, if there are two async iterators that you want to simultaneously wait on, this can be done with: select = Select ( name1 = receiver1 , name2 = receiver2 ) while await select . ready (): if msg := select . name1 : if val := msg . inner : # do something with `val` pass else : # handle closure of receiver. pass elif msg := select . name2 : # do something with `msg.inner` pass Source code in frequenz/channels/select.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class Select : \"\"\"Select the next available message from a group of AsyncIterators. If `Select` was created with more `AsyncIterator` than what are read in the if-chain after each call to [ready()][frequenz.channels.Select.ready], messages coming in the additional async iterators are dropped, and a warning message is logged. [Receiver][frequenz.channels.Receiver]s also function as `AsyncIterator`. Example: For example, if there are two async iterators that you want to simultaneously wait on, this can be done with: ```python select = Select(name1 = receiver1, name2 = receiver2) while await select.ready(): if msg := select.name1: if val := msg.inner: # do something with `val` pass else: # handle closure of receiver. pass elif msg := select.name2: # do something with `msg.inner` pass ``` \"\"\" def __init__ ( self , ** kwargs : AsyncIterator [ Any ]) -> None : \"\"\"Create a `Select` instance. Args: **kwargs: sequence of async iterators \"\"\" self . _receivers = kwargs self . _pending : Set [ asyncio . Task [ Any ]] = set () for name , recv in self . _receivers . items (): # can replace __anext__() to anext() (Only Python 3.10>=) msg = recv . __anext__ () # pylint: disable=unnecessary-dunder-call self . _pending . add ( asyncio . create_task ( msg , name = name )) # type: ignore self . _ready_count = 0 self . _prev_ready_count = 0 self . _result : Dict [ str , Optional [ _Selected ]] = { name : None for name in self . _receivers } def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel () async def ready ( self ) -> bool : \"\"\"Wait until there is a message in any of the async iterators. Returns `True` if there is a message available, and `False` if all async iterators have closed. Returns: Whether there are further messages or not. \"\"\" if self . _ready_count > 0 : if self . _ready_count == self . _prev_ready_count : dropped_names : List [ str ] = [] for name , value in self . _result . items (): if value is not None : dropped_names . append ( name ) self . _result [ name ] = None self . _ready_count = 0 self . _prev_ready_count = 0 logger . warning ( \"Select.ready() dropped data from async iterator(s): %s , \" \"because no messages have been fetched since the last call to ready().\" , dropped_names , ) else : self . _prev_ready_count = self . _ready_count return True if len ( self . _pending ) == 0 : return False # once all the pending messages have been consumed, reset the # `_prev_ready_count` as well, and wait for new messages. self . _prev_ready_count = 0 done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () if isinstance ( item . exception (), StopAsyncIteration ): result = None else : result = item . result () self . _ready_count += 1 self . _result [ name ] = _Selected ( result ) # if channel or AsyncIterator is closed # don't add a task for it again. if result is None : continue msg = self . _receivers [ # pylint: disable=unnecessary-dunder-call name ] . __anext__ () self . _pending . add ( asyncio . create_task ( msg , name = name )) # type: ignore return True def __getattr__ ( self , name : str ) -> Optional [ Any ]: \"\"\"Return the latest unread message from a `AsyncIterator`, if available. Args: name: Name of the channel. Returns: Latest unread message for the specified `AsyncIterator`, or `None`. Raises: KeyError: when the name was not specified when creating the `Select` instance. \"\"\" result = self . _result [ name ] if result is None : return result self . _result [ name ] = None self . _ready_count -= 1 return result Functions \u00a4 __del__ () \u00a4 Cleanup any pending tasks. Source code in frequenz/channels/select.py 81 82 83 84 def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel () __getattr__ ( name ) \u00a4 Return the latest unread message from a AsyncIterator , if available. PARAMETER DESCRIPTION name Name of the channel. TYPE: str RETURNS DESCRIPTION Optional [ Any ] Latest unread message for the specified AsyncIterator , or None . RAISES DESCRIPTION KeyError when the name was not specified when creating the Select instance. Source code in frequenz/channels/select.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def __getattr__ ( self , name : str ) -> Optional [ Any ]: \"\"\"Return the latest unread message from a `AsyncIterator`, if available. Args: name: Name of the channel. Returns: Latest unread message for the specified `AsyncIterator`, or `None`. Raises: KeyError: when the name was not specified when creating the `Select` instance. \"\"\" result = self . _result [ name ] if result is None : return result self . _result [ name ] = None self . _ready_count -= 1 return result __init__ ( ** kwargs ) \u00a4 Create a Select instance. PARAMETER DESCRIPTION **kwargs sequence of async iterators TYPE: AsyncIterator [ Any ] DEFAULT: {} Source code in frequenz/channels/select.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def __init__ ( self , ** kwargs : AsyncIterator [ Any ]) -> None : \"\"\"Create a `Select` instance. Args: **kwargs: sequence of async iterators \"\"\" self . _receivers = kwargs self . _pending : Set [ asyncio . Task [ Any ]] = set () for name , recv in self . _receivers . items (): # can replace __anext__() to anext() (Only Python 3.10>=) msg = recv . __anext__ () # pylint: disable=unnecessary-dunder-call self . _pending . add ( asyncio . create_task ( msg , name = name )) # type: ignore self . _ready_count = 0 self . _prev_ready_count = 0 self . _result : Dict [ str , Optional [ _Selected ]] = { name : None for name in self . _receivers } ready () async \u00a4 Wait until there is a message in any of the async iterators. Returns True if there is a message available, and False if all async iterators have closed. RETURNS DESCRIPTION bool Whether there are further messages or not. Source code in frequenz/channels/select.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 async def ready ( self ) -> bool : \"\"\"Wait until there is a message in any of the async iterators. Returns `True` if there is a message available, and `False` if all async iterators have closed. Returns: Whether there are further messages or not. \"\"\" if self . _ready_count > 0 : if self . _ready_count == self . _prev_ready_count : dropped_names : List [ str ] = [] for name , value in self . _result . items (): if value is not None : dropped_names . append ( name ) self . _result [ name ] = None self . _ready_count = 0 self . _prev_ready_count = 0 logger . warning ( \"Select.ready() dropped data from async iterator(s): %s , \" \"because no messages have been fetched since the last call to ready().\" , dropped_names , ) else : self . _prev_ready_count = self . _ready_count return True if len ( self . _pending ) == 0 : return False # once all the pending messages have been consumed, reset the # `_prev_ready_count` as well, and wait for new messages. self . _prev_ready_count = 0 done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () if isinstance ( item . exception (), StopAsyncIteration ): result = None else : result = item . result () self . _ready_count += 1 self . _result [ name ] = _Selected ( result ) # if channel or AsyncIterator is closed # don't add a task for it again. if result is None : continue msg = self . _receivers [ # pylint: disable=unnecessary-dunder-call name ] . __anext__ () self . _pending . add ( asyncio . create_task ( msg , name = name )) # type: ignore return True","title":"select"},{"location":"reference/frequenz/channels/select/#frequenz.channels.select","text":"Select the first among multiple AsyncIterators. Expects AsyncIterator class to raise StopAsyncIteration exception once no more messages are expected or the channel is closed in case of Receiver class.","title":"select"},{"location":"reference/frequenz/channels/select/#frequenz.channels.select-classes","text":"","title":"Classes"},{"location":"reference/frequenz/channels/select/#frequenz.channels.select.Select","text":"Select the next available message from a group of AsyncIterators. If Select was created with more AsyncIterator than what are read in the if-chain after each call to ready() , messages coming in the additional async iterators are dropped, and a warning message is logged. Receiver s also function as AsyncIterator . Example For example, if there are two async iterators that you want to simultaneously wait on, this can be done with: select = Select ( name1 = receiver1 , name2 = receiver2 ) while await select . ready (): if msg := select . name1 : if val := msg . inner : # do something with `val` pass else : # handle closure of receiver. pass elif msg := select . name2 : # do something with `msg.inner` pass Source code in frequenz/channels/select.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class Select : \"\"\"Select the next available message from a group of AsyncIterators. If `Select` was created with more `AsyncIterator` than what are read in the if-chain after each call to [ready()][frequenz.channels.Select.ready], messages coming in the additional async iterators are dropped, and a warning message is logged. [Receiver][frequenz.channels.Receiver]s also function as `AsyncIterator`. Example: For example, if there are two async iterators that you want to simultaneously wait on, this can be done with: ```python select = Select(name1 = receiver1, name2 = receiver2) while await select.ready(): if msg := select.name1: if val := msg.inner: # do something with `val` pass else: # handle closure of receiver. pass elif msg := select.name2: # do something with `msg.inner` pass ``` \"\"\" def __init__ ( self , ** kwargs : AsyncIterator [ Any ]) -> None : \"\"\"Create a `Select` instance. Args: **kwargs: sequence of async iterators \"\"\" self . _receivers = kwargs self . _pending : Set [ asyncio . Task [ Any ]] = set () for name , recv in self . _receivers . items (): # can replace __anext__() to anext() (Only Python 3.10>=) msg = recv . __anext__ () # pylint: disable=unnecessary-dunder-call self . _pending . add ( asyncio . create_task ( msg , name = name )) # type: ignore self . _ready_count = 0 self . _prev_ready_count = 0 self . _result : Dict [ str , Optional [ _Selected ]] = { name : None for name in self . _receivers } def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel () async def ready ( self ) -> bool : \"\"\"Wait until there is a message in any of the async iterators. Returns `True` if there is a message available, and `False` if all async iterators have closed. Returns: Whether there are further messages or not. \"\"\" if self . _ready_count > 0 : if self . _ready_count == self . _prev_ready_count : dropped_names : List [ str ] = [] for name , value in self . _result . items (): if value is not None : dropped_names . append ( name ) self . _result [ name ] = None self . _ready_count = 0 self . _prev_ready_count = 0 logger . warning ( \"Select.ready() dropped data from async iterator(s): %s , \" \"because no messages have been fetched since the last call to ready().\" , dropped_names , ) else : self . _prev_ready_count = self . _ready_count return True if len ( self . _pending ) == 0 : return False # once all the pending messages have been consumed, reset the # `_prev_ready_count` as well, and wait for new messages. self . _prev_ready_count = 0 done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () if isinstance ( item . exception (), StopAsyncIteration ): result = None else : result = item . result () self . _ready_count += 1 self . _result [ name ] = _Selected ( result ) # if channel or AsyncIterator is closed # don't add a task for it again. if result is None : continue msg = self . _receivers [ # pylint: disable=unnecessary-dunder-call name ] . __anext__ () self . _pending . add ( asyncio . create_task ( msg , name = name )) # type: ignore return True def __getattr__ ( self , name : str ) -> Optional [ Any ]: \"\"\"Return the latest unread message from a `AsyncIterator`, if available. Args: name: Name of the channel. Returns: Latest unread message for the specified `AsyncIterator`, or `None`. Raises: KeyError: when the name was not specified when creating the `Select` instance. \"\"\" result = self . _result [ name ] if result is None : return result self . _result [ name ] = None self . _ready_count -= 1 return result","title":"Select"},{"location":"reference/frequenz/channels/select/#frequenz.channels.select.Select-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/select/#frequenz.channels.select.Select.__del__","text":"Cleanup any pending tasks. Source code in frequenz/channels/select.py 81 82 83 84 def __del__ ( self ) -> None : \"\"\"Cleanup any pending tasks.\"\"\" for task in self . _pending : task . cancel ()","title":"__del__()"},{"location":"reference/frequenz/channels/select/#frequenz.channels.select.Select.__getattr__","text":"Return the latest unread message from a AsyncIterator , if available. PARAMETER DESCRIPTION name Name of the channel. TYPE: str RETURNS DESCRIPTION Optional [ Any ] Latest unread message for the specified AsyncIterator , or None . RAISES DESCRIPTION KeyError when the name was not specified when creating the Select instance. Source code in frequenz/channels/select.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 def __getattr__ ( self , name : str ) -> Optional [ Any ]: \"\"\"Return the latest unread message from a `AsyncIterator`, if available. Args: name: Name of the channel. Returns: Latest unread message for the specified `AsyncIterator`, or `None`. Raises: KeyError: when the name was not specified when creating the `Select` instance. \"\"\" result = self . _result [ name ] if result is None : return result self . _result [ name ] = None self . _ready_count -= 1 return result","title":"__getattr__()"},{"location":"reference/frequenz/channels/select/#frequenz.channels.select.Select.__init__","text":"Create a Select instance. PARAMETER DESCRIPTION **kwargs sequence of async iterators TYPE: AsyncIterator [ Any ] DEFAULT: {} Source code in frequenz/channels/select.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def __init__ ( self , ** kwargs : AsyncIterator [ Any ]) -> None : \"\"\"Create a `Select` instance. Args: **kwargs: sequence of async iterators \"\"\" self . _receivers = kwargs self . _pending : Set [ asyncio . Task [ Any ]] = set () for name , recv in self . _receivers . items (): # can replace __anext__() to anext() (Only Python 3.10>=) msg = recv . __anext__ () # pylint: disable=unnecessary-dunder-call self . _pending . add ( asyncio . create_task ( msg , name = name )) # type: ignore self . _ready_count = 0 self . _prev_ready_count = 0 self . _result : Dict [ str , Optional [ _Selected ]] = { name : None for name in self . _receivers }","title":"__init__()"},{"location":"reference/frequenz/channels/select/#frequenz.channels.select.Select.ready","text":"Wait until there is a message in any of the async iterators. Returns True if there is a message available, and False if all async iterators have closed. RETURNS DESCRIPTION bool Whether there are further messages or not. Source code in frequenz/channels/select.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 async def ready ( self ) -> bool : \"\"\"Wait until there is a message in any of the async iterators. Returns `True` if there is a message available, and `False` if all async iterators have closed. Returns: Whether there are further messages or not. \"\"\" if self . _ready_count > 0 : if self . _ready_count == self . _prev_ready_count : dropped_names : List [ str ] = [] for name , value in self . _result . items (): if value is not None : dropped_names . append ( name ) self . _result [ name ] = None self . _ready_count = 0 self . _prev_ready_count = 0 logger . warning ( \"Select.ready() dropped data from async iterator(s): %s , \" \"because no messages have been fetched since the last call to ready().\" , dropped_names , ) else : self . _prev_ready_count = self . _ready_count return True if len ( self . _pending ) == 0 : return False # once all the pending messages have been consumed, reset the # `_prev_ready_count` as well, and wait for new messages. self . _prev_ready_count = 0 done , self . _pending = await asyncio . wait ( self . _pending , return_when = asyncio . FIRST_COMPLETED ) for item in done : name = item . get_name () if isinstance ( item . exception (), StopAsyncIteration ): result = None else : result = item . result () self . _ready_count += 1 self . _result [ name ] = _Selected ( result ) # if channel or AsyncIterator is closed # don't add a task for it again. if result is None : continue msg = self . _receivers [ # pylint: disable=unnecessary-dunder-call name ] . __anext__ () self . _pending . add ( asyncio . create_task ( msg , name = name )) # type: ignore return True","title":"ready()"},{"location":"reference/frequenz/channels/utils/","text":"frequenz.channels.utils \u00a4 Channel utilities.","title":"utils"},{"location":"reference/frequenz/channels/utils/#frequenz.channels.utils","text":"Channel utilities.","title":"utils"},{"location":"reference/frequenz/channels/utils/file_watcher/","text":"frequenz.channels.utils.file_watcher \u00a4 A Channel receiver for watching for new (or modified) files. Classes \u00a4 frequenz.channels.utils.file_watcher.EventType \u00a4 Bases: Enum Available types of changes to watch for. Source code in frequenz/channels/utils/file_watcher.py 15 16 17 18 19 20 class EventType ( Enum ): \"\"\"Available types of changes to watch for.\"\"\" CREATE = Change . added MODIFY = Change . modified DELETE = Change . deleted frequenz.channels.utils.file_watcher.FileWatcher \u00a4 Bases: Receiver [ pathlib . Path ] A channel receiver that watches for file events. Source code in frequenz/channels/utils/file_watcher.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class FileWatcher ( Receiver [ pathlib . Path ]): \"\"\"A channel receiver that watches for file events.\"\"\" def __init__ ( self , paths : List [ Union [ pathlib . Path , str ]], event_types : Optional [ Set [ EventType ]] = None , ) -> None : \"\"\"Create a `FileWatcher` instance. Args: paths: Paths to watch for changes. event_types: Types of events to watch for or `None` to watch for all event types. \"\"\" if event_types is None : event_types = { EventType . CREATE , EventType . MODIFY , EventType . DELETE } self . event_types = event_types self . _stop_event = asyncio . Event () self . _paths = [ path if isinstance ( path , pathlib . Path ) else pathlib . Path ( path ) for path in paths ] self . _awatch = awatch ( * self . _paths , stop_event = self . _stop_event , watch_filter = lambda change , path_str : ( change in [ event_type . value for event_type in event_types ] # type: ignore and pathlib . Path ( path_str ) . is_file () ), ) def __del__ ( self ) -> None : \"\"\"Cleanup registered watches. `awatch` passes the `stop_event` to a separate task/thread. This way `awatch` getting destroyed properly. The background task will continue until the signal is received. \"\"\" self . _stop_event . set () async def receive ( self ) -> Optional [ pathlib . Path ]: \"\"\"Wait for the next file event and return its path. Returns: Path of next file. \"\"\" while True : changes = await self . _awatch . __anext__ () for change in changes : # Tuple of (Change, path) returned by watchfiles if change is None or len ( change ) != 2 : return None _ , path_str = change path = pathlib . Path ( path_str ) return path Functions \u00a4 __del__ () \u00a4 Cleanup registered watches. awatch passes the stop_event to a separate task/thread. This way awatch getting destroyed properly. The background task will continue until the signal is received. Source code in frequenz/channels/utils/file_watcher.py 56 57 58 59 60 61 62 63 def __del__ ( self ) -> None : \"\"\"Cleanup registered watches. `awatch` passes the `stop_event` to a separate task/thread. This way `awatch` getting destroyed properly. The background task will continue until the signal is received. \"\"\" self . _stop_event . set () __init__ ( paths , event_types = None ) \u00a4 Create a FileWatcher instance. PARAMETER DESCRIPTION paths Paths to watch for changes. TYPE: List [ Union [ pathlib . Path , str ]] event_types Types of events to watch for or None to watch for all event types. TYPE: Optional [ Set [ EventType ]] DEFAULT: None Source code in frequenz/channels/utils/file_watcher.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def __init__ ( self , paths : List [ Union [ pathlib . Path , str ]], event_types : Optional [ Set [ EventType ]] = None , ) -> None : \"\"\"Create a `FileWatcher` instance. Args: paths: Paths to watch for changes. event_types: Types of events to watch for or `None` to watch for all event types. \"\"\" if event_types is None : event_types = { EventType . CREATE , EventType . MODIFY , EventType . DELETE } self . event_types = event_types self . _stop_event = asyncio . Event () self . _paths = [ path if isinstance ( path , pathlib . Path ) else pathlib . Path ( path ) for path in paths ] self . _awatch = awatch ( * self . _paths , stop_event = self . _stop_event , watch_filter = lambda change , path_str : ( change in [ event_type . value for event_type in event_types ] # type: ignore and pathlib . Path ( path_str ) . is_file () ), ) receive () async \u00a4 Wait for the next file event and return its path. RETURNS DESCRIPTION Optional [ pathlib . Path ] Path of next file. Source code in frequenz/channels/utils/file_watcher.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 async def receive ( self ) -> Optional [ pathlib . Path ]: \"\"\"Wait for the next file event and return its path. Returns: Path of next file. \"\"\" while True : changes = await self . _awatch . __anext__ () for change in changes : # Tuple of (Change, path) returned by watchfiles if change is None or len ( change ) != 2 : return None _ , path_str = change path = pathlib . Path ( path_str ) return path","title":"file_watcher"},{"location":"reference/frequenz/channels/utils/file_watcher/#frequenz.channels.utils.file_watcher","text":"A Channel receiver for watching for new (or modified) files.","title":"file_watcher"},{"location":"reference/frequenz/channels/utils/file_watcher/#frequenz.channels.utils.file_watcher-classes","text":"","title":"Classes"},{"location":"reference/frequenz/channels/utils/file_watcher/#frequenz.channels.utils.file_watcher.EventType","text":"Bases: Enum Available types of changes to watch for. Source code in frequenz/channels/utils/file_watcher.py 15 16 17 18 19 20 class EventType ( Enum ): \"\"\"Available types of changes to watch for.\"\"\" CREATE = Change . added MODIFY = Change . modified DELETE = Change . deleted","title":"EventType"},{"location":"reference/frequenz/channels/utils/file_watcher/#frequenz.channels.utils.file_watcher.FileWatcher","text":"Bases: Receiver [ pathlib . Path ] A channel receiver that watches for file events. Source code in frequenz/channels/utils/file_watcher.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 class FileWatcher ( Receiver [ pathlib . Path ]): \"\"\"A channel receiver that watches for file events.\"\"\" def __init__ ( self , paths : List [ Union [ pathlib . Path , str ]], event_types : Optional [ Set [ EventType ]] = None , ) -> None : \"\"\"Create a `FileWatcher` instance. Args: paths: Paths to watch for changes. event_types: Types of events to watch for or `None` to watch for all event types. \"\"\" if event_types is None : event_types = { EventType . CREATE , EventType . MODIFY , EventType . DELETE } self . event_types = event_types self . _stop_event = asyncio . Event () self . _paths = [ path if isinstance ( path , pathlib . Path ) else pathlib . Path ( path ) for path in paths ] self . _awatch = awatch ( * self . _paths , stop_event = self . _stop_event , watch_filter = lambda change , path_str : ( change in [ event_type . value for event_type in event_types ] # type: ignore and pathlib . Path ( path_str ) . is_file () ), ) def __del__ ( self ) -> None : \"\"\"Cleanup registered watches. `awatch` passes the `stop_event` to a separate task/thread. This way `awatch` getting destroyed properly. The background task will continue until the signal is received. \"\"\" self . _stop_event . set () async def receive ( self ) -> Optional [ pathlib . Path ]: \"\"\"Wait for the next file event and return its path. Returns: Path of next file. \"\"\" while True : changes = await self . _awatch . __anext__ () for change in changes : # Tuple of (Change, path) returned by watchfiles if change is None or len ( change ) != 2 : return None _ , path_str = change path = pathlib . Path ( path_str ) return path","title":"FileWatcher"},{"location":"reference/frequenz/channels/utils/file_watcher/#frequenz.channels.utils.file_watcher.FileWatcher-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/utils/file_watcher/#frequenz.channels.utils.file_watcher.FileWatcher.__del__","text":"Cleanup registered watches. awatch passes the stop_event to a separate task/thread. This way awatch getting destroyed properly. The background task will continue until the signal is received. Source code in frequenz/channels/utils/file_watcher.py 56 57 58 59 60 61 62 63 def __del__ ( self ) -> None : \"\"\"Cleanup registered watches. `awatch` passes the `stop_event` to a separate task/thread. This way `awatch` getting destroyed properly. The background task will continue until the signal is received. \"\"\" self . _stop_event . set ()","title":"__del__()"},{"location":"reference/frequenz/channels/utils/file_watcher/#frequenz.channels.utils.file_watcher.FileWatcher.__init__","text":"Create a FileWatcher instance. PARAMETER DESCRIPTION paths Paths to watch for changes. TYPE: List [ Union [ pathlib . Path , str ]] event_types Types of events to watch for or None to watch for all event types. TYPE: Optional [ Set [ EventType ]] DEFAULT: None Source code in frequenz/channels/utils/file_watcher.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def __init__ ( self , paths : List [ Union [ pathlib . Path , str ]], event_types : Optional [ Set [ EventType ]] = None , ) -> None : \"\"\"Create a `FileWatcher` instance. Args: paths: Paths to watch for changes. event_types: Types of events to watch for or `None` to watch for all event types. \"\"\" if event_types is None : event_types = { EventType . CREATE , EventType . MODIFY , EventType . DELETE } self . event_types = event_types self . _stop_event = asyncio . Event () self . _paths = [ path if isinstance ( path , pathlib . Path ) else pathlib . Path ( path ) for path in paths ] self . _awatch = awatch ( * self . _paths , stop_event = self . _stop_event , watch_filter = lambda change , path_str : ( change in [ event_type . value for event_type in event_types ] # type: ignore and pathlib . Path ( path_str ) . is_file () ), )","title":"__init__()"},{"location":"reference/frequenz/channels/utils/file_watcher/#frequenz.channels.utils.file_watcher.FileWatcher.receive","text":"Wait for the next file event and return its path. RETURNS DESCRIPTION Optional [ pathlib . Path ] Path of next file. Source code in frequenz/channels/utils/file_watcher.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 async def receive ( self ) -> Optional [ pathlib . Path ]: \"\"\"Wait for the next file event and return its path. Returns: Path of next file. \"\"\" while True : changes = await self . _awatch . __anext__ () for change in changes : # Tuple of (Change, path) returned by watchfiles if change is None or len ( change ) != 2 : return None _ , path_str = change path = pathlib . Path ( path_str ) return path","title":"receive()"},{"location":"reference/frequenz/channels/utils/timer/","text":"frequenz.channels.utils.timer \u00a4 A timer receiver that returns the timestamp every interval . Classes \u00a4 frequenz.channels.utils.timer.Timer \u00a4 Bases: Receiver [ datetime ] A timer receiver that returns the timestamp every interval seconds. Primarily for use with Select . Example When you want something to happen with a fixed period: timer = channel . Timer ( 30.0 ) select = Select ( bat_1 = receiver1 , timer = timer ) while await select . ready (): if msg := select . bat_1 : if val := msg . inner : process_data ( val ) else : logging . warn ( \"battery channel closed\" ) if ts := select . timer : # something to do once every 30 seconds pass When you want something to happen when nothing else has happened in a certain interval: timer = channel . Timer ( 30.0 ) select = Select ( bat_1 = receiver1 , timer = timer ) while await select . ready (): timer . reset () if msg := select . bat_1 : if val := msg . inner : process_data ( val ) else : logging . warn ( \"battery channel closed\" ) if ts := select . timer : # something to do if there's no battery data for 30 seconds pass Source code in frequenz/channels/utils/timer.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class Timer ( Receiver [ datetime ]): \"\"\"A timer receiver that returns the timestamp every `interval` seconds. Primarily for use with [Select][frequenz.channels.Select]. Example: When you want something to happen with a fixed period: ```python timer = channel.Timer(30.0) select = Select(bat_1 = receiver1, timer = timer) while await select.ready(): if msg := select.bat_1: if val := msg.inner: process_data(val) else: logging.warn(\"battery channel closed\") if ts := select.timer: # something to do once every 30 seconds pass ``` When you want something to happen when nothing else has happened in a certain interval: ```python timer = channel.Timer(30.0) select = Select(bat_1 = receiver1, timer = timer) while await select.ready(): timer.reset() if msg := select.bat_1: if val := msg.inner: process_data(val) else: logging.warn(\"battery channel closed\") if ts := select.timer: # something to do if there's no battery data for 30 seconds pass ``` \"\"\" def __init__ ( self , interval : float ) -> None : \"\"\"Create a `Timer` instance. Args: interval: number of seconds between messages. \"\"\" self . _stopped = False self . _interval = timedelta ( seconds = interval ) self . _next_msg_time = datetime . now () + self . _interval def reset ( self ) -> None : \"\"\"Reset the timer to start timing from `now`.\"\"\" self . _next_msg_time = datetime . now () + self . _interval def stop ( self ) -> None : \"\"\"Stop the timer. Once `stop` has been called, all subsequent calls to [receive()][frequenz.channels.Timer.receive] will immediately return `None`. \"\"\" self . _stopped = True async def receive ( self ) -> Optional [ datetime ]: \"\"\"Return the current time once the next tick is due. Returns: The time of the next tick or `None` if [stop()][frequenz.channels.Timer.stop] has been called on the timer. \"\"\" if self . _stopped : return None now = datetime . now () diff = self . _next_msg_time - now while diff . total_seconds () > 0 : await asyncio . sleep ( diff . total_seconds ()) now = datetime . now () diff = self . _next_msg_time - now self . _next_msg_time = now + self . _interval return now Functions \u00a4 __init__ ( interval ) \u00a4 Create a Timer instance. PARAMETER DESCRIPTION interval number of seconds between messages. TYPE: float Source code in frequenz/channels/utils/timer.py 54 55 56 57 58 59 60 61 62 def __init__ ( self , interval : float ) -> None : \"\"\"Create a `Timer` instance. Args: interval: number of seconds between messages. \"\"\" self . _stopped = False self . _interval = timedelta ( seconds = interval ) self . _next_msg_time = datetime . now () + self . _interval receive () async \u00a4 Return the current time once the next tick is due. RETURNS DESCRIPTION Optional [ datetime ] The time of the next tick or None if stop() has been called on the timer. Source code in frequenz/channels/utils/timer.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 async def receive ( self ) -> Optional [ datetime ]: \"\"\"Return the current time once the next tick is due. Returns: The time of the next tick or `None` if [stop()][frequenz.channels.Timer.stop] has been called on the timer. \"\"\" if self . _stopped : return None now = datetime . now () diff = self . _next_msg_time - now while diff . total_seconds () > 0 : await asyncio . sleep ( diff . total_seconds ()) now = datetime . now () diff = self . _next_msg_time - now self . _next_msg_time = now + self . _interval return now reset () \u00a4 Reset the timer to start timing from now . Source code in frequenz/channels/utils/timer.py 64 65 66 def reset ( self ) -> None : \"\"\"Reset the timer to start timing from `now`.\"\"\" self . _next_msg_time = datetime . now () + self . _interval stop () \u00a4 Stop the timer. Once stop has been called, all subsequent calls to receive() will immediately return None . Source code in frequenz/channels/utils/timer.py 68 69 70 71 72 73 74 75 def stop ( self ) -> None : \"\"\"Stop the timer. Once `stop` has been called, all subsequent calls to [receive()][frequenz.channels.Timer.receive] will immediately return `None`. \"\"\" self . _stopped = True","title":"timer"},{"location":"reference/frequenz/channels/utils/timer/#frequenz.channels.utils.timer","text":"A timer receiver that returns the timestamp every interval .","title":"timer"},{"location":"reference/frequenz/channels/utils/timer/#frequenz.channels.utils.timer-classes","text":"","title":"Classes"},{"location":"reference/frequenz/channels/utils/timer/#frequenz.channels.utils.timer.Timer","text":"Bases: Receiver [ datetime ] A timer receiver that returns the timestamp every interval seconds. Primarily for use with Select . Example When you want something to happen with a fixed period: timer = channel . Timer ( 30.0 ) select = Select ( bat_1 = receiver1 , timer = timer ) while await select . ready (): if msg := select . bat_1 : if val := msg . inner : process_data ( val ) else : logging . warn ( \"battery channel closed\" ) if ts := select . timer : # something to do once every 30 seconds pass When you want something to happen when nothing else has happened in a certain interval: timer = channel . Timer ( 30.0 ) select = Select ( bat_1 = receiver1 , timer = timer ) while await select . ready (): timer . reset () if msg := select . bat_1 : if val := msg . inner : process_data ( val ) else : logging . warn ( \"battery channel closed\" ) if ts := select . timer : # something to do if there's no battery data for 30 seconds pass Source code in frequenz/channels/utils/timer.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 class Timer ( Receiver [ datetime ]): \"\"\"A timer receiver that returns the timestamp every `interval` seconds. Primarily for use with [Select][frequenz.channels.Select]. Example: When you want something to happen with a fixed period: ```python timer = channel.Timer(30.0) select = Select(bat_1 = receiver1, timer = timer) while await select.ready(): if msg := select.bat_1: if val := msg.inner: process_data(val) else: logging.warn(\"battery channel closed\") if ts := select.timer: # something to do once every 30 seconds pass ``` When you want something to happen when nothing else has happened in a certain interval: ```python timer = channel.Timer(30.0) select = Select(bat_1 = receiver1, timer = timer) while await select.ready(): timer.reset() if msg := select.bat_1: if val := msg.inner: process_data(val) else: logging.warn(\"battery channel closed\") if ts := select.timer: # something to do if there's no battery data for 30 seconds pass ``` \"\"\" def __init__ ( self , interval : float ) -> None : \"\"\"Create a `Timer` instance. Args: interval: number of seconds between messages. \"\"\" self . _stopped = False self . _interval = timedelta ( seconds = interval ) self . _next_msg_time = datetime . now () + self . _interval def reset ( self ) -> None : \"\"\"Reset the timer to start timing from `now`.\"\"\" self . _next_msg_time = datetime . now () + self . _interval def stop ( self ) -> None : \"\"\"Stop the timer. Once `stop` has been called, all subsequent calls to [receive()][frequenz.channels.Timer.receive] will immediately return `None`. \"\"\" self . _stopped = True async def receive ( self ) -> Optional [ datetime ]: \"\"\"Return the current time once the next tick is due. Returns: The time of the next tick or `None` if [stop()][frequenz.channels.Timer.stop] has been called on the timer. \"\"\" if self . _stopped : return None now = datetime . now () diff = self . _next_msg_time - now while diff . total_seconds () > 0 : await asyncio . sleep ( diff . total_seconds ()) now = datetime . now () diff = self . _next_msg_time - now self . _next_msg_time = now + self . _interval return now","title":"Timer"},{"location":"reference/frequenz/channels/utils/timer/#frequenz.channels.utils.timer.Timer-functions","text":"","title":"Functions"},{"location":"reference/frequenz/channels/utils/timer/#frequenz.channels.utils.timer.Timer.__init__","text":"Create a Timer instance. PARAMETER DESCRIPTION interval number of seconds between messages. TYPE: float Source code in frequenz/channels/utils/timer.py 54 55 56 57 58 59 60 61 62 def __init__ ( self , interval : float ) -> None : \"\"\"Create a `Timer` instance. Args: interval: number of seconds between messages. \"\"\" self . _stopped = False self . _interval = timedelta ( seconds = interval ) self . _next_msg_time = datetime . now () + self . _interval","title":"__init__()"},{"location":"reference/frequenz/channels/utils/timer/#frequenz.channels.utils.timer.Timer.receive","text":"Return the current time once the next tick is due. RETURNS DESCRIPTION Optional [ datetime ] The time of the next tick or None if stop() has been called on the timer. Source code in frequenz/channels/utils/timer.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 async def receive ( self ) -> Optional [ datetime ]: \"\"\"Return the current time once the next tick is due. Returns: The time of the next tick or `None` if [stop()][frequenz.channels.Timer.stop] has been called on the timer. \"\"\" if self . _stopped : return None now = datetime . now () diff = self . _next_msg_time - now while diff . total_seconds () > 0 : await asyncio . sleep ( diff . total_seconds ()) now = datetime . now () diff = self . _next_msg_time - now self . _next_msg_time = now + self . _interval return now","title":"receive()"},{"location":"reference/frequenz/channels/utils/timer/#frequenz.channels.utils.timer.Timer.reset","text":"Reset the timer to start timing from now . Source code in frequenz/channels/utils/timer.py 64 65 66 def reset ( self ) -> None : \"\"\"Reset the timer to start timing from `now`.\"\"\" self . _next_msg_time = datetime . now () + self . _interval","title":"reset()"},{"location":"reference/frequenz/channels/utils/timer/#frequenz.channels.utils.timer.Timer.stop","text":"Stop the timer. Once stop has been called, all subsequent calls to receive() will immediately return None . Source code in frequenz/channels/utils/timer.py 68 69 70 71 72 73 74 75 def stop ( self ) -> None : \"\"\"Stop the timer. Once `stop` has been called, all subsequent calls to [receive()][frequenz.channels.Timer.receive] will immediately return `None`. \"\"\" self . _stopped = True","title":"stop()"}]}